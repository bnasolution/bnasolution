(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s); new MutationObserver(s => { for (const o of s) if (o.type === "childList") for (const i of o.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && r(i) }).observe(document, { childList: !0, subtree: !0 }); function n(s) { const o = {}; return s.integrity && (o.integrity = s.integrity), s.referrerPolicy && (o.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? o.credentials = "include" : s.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function r(s) { if (s.ep) return; s.ep = !0; const o = n(s); fetch(s.href, o) } })();/**
* @vue/shared v3.4.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Is(e, t) { const n = new Set(e.split(",")); return t ? r => n.has(r.toLowerCase()) : r => n.has(r) } const ae = {}, Gt = [], Be = () => { }, Eu = () => !1, xr = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Ls = e => e.startsWith("onUpdate:"), be = Object.assign, Ms = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }, Tu = Object.prototype.hasOwnProperty, te = (e, t) => Tu.call(e, t), K = Array.isArray, qt = e => Er(e) === "[object Map]", Xi = e => Er(e) === "[object Set]", q = e => typeof e == "function", he = e => typeof e == "string", $t = e => typeof e == "symbol", ie = e => e !== null && typeof e == "object", Ji = e => (ie(e) || q(e)) && q(e.then) && q(e.catch), Qi = Object.prototype.toString, Er = e => Qi.call(e), Au = e => Er(e).slice(8, -1), el = e => Er(e) === "[object Object]", Fs = e => he(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, dn = Is(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Tr = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, Ou = /-(\w)/g, Ge = Tr(e => e.replace(Ou, (t, n) => n ? n.toUpperCase() : "")), ku = /\B([A-Z])/g, Qt = Tr(e => e.replace(ku, "-$1").toLowerCase()), st = Tr(e => e.charAt(0).toUpperCase() + e.slice(1)), jr = Tr(e => e ? `on${st(e)}` : ""), bt = (e, t) => !Object.is(e, t), Wr = (e, t) => { for (let n = 0; n < e.length; n++)e[n](t) }, tl = (e, t, n) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: n }) }, Pu = e => { const t = parseFloat(e); return isNaN(t) ? e : t }, Iu = e => { const t = he(e) ? Number(e) : NaN; return isNaN(t) ? e : t }; let wo; const nl = () => wo || (wo = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Ds(e) { if (K(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n], s = he(r) ? Du(r) : Ds(r); if (s) for (const o in s) t[o] = s[o] } return t } else if (he(e) || ie(e)) return e } const Lu = /;(?![^(]*\))/g, Mu = /:([^]+)/, Fu = /\/\*[^]*?\*\//g; function Du(e) { const t = {}; return e.replace(Fu, "").split(Lu).forEach(n => { if (n) { const r = n.split(Mu); r.length > 1 && (t[r[0].trim()] = r[1].trim()) } }), t } function Rs(e) { let t = ""; if (he(e)) t = e; else if (K(e)) for (let n = 0; n < e.length; n++) { const r = Rs(e[n]); r && (t += r + " ") } else if (ie(e)) for (const n in e) e[n] && (t += n + " "); return t.trim() } const Ru = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", $u = Is(Ru); function rl(e) { return !!e || e === "" } const sl = e => he(e) ? e : e == null ? "" : K(e) || ie(e) && (e.toString === Qi || !q(e.toString)) ? JSON.stringify(e, ol, 2) : String(e), ol = (e, t) => t && t.__v_isRef ? ol(e, t.value) : qt(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [r, s], o) => (n[zr(r, o) + " =>"] = s, n), {}) } : Xi(t) ? { [`Set(${t.size})`]: [...t.values()].map(n => zr(n)) } : $t(t) ? zr(t) : ie(t) && !K(t) && !el(t) ? String(t) : t, zr = (e, t = "") => { var n; return $t(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e };/**
* @vue/reactivity v3.4.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let De; class il { constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = De, !t && De && (this.index = (De.scopes || (De.scopes = [])).push(this) - 1) } get active() { return this._active } run(t) { if (this._active) { const n = De; try { return De = this, t() } finally { De = n } } } on() { De = this } off() { De = this.parent } stop(t) { if (this._active) { let n, r; for (n = 0, r = this.effects.length; n < r; n++)this.effects[n].stop(); for (n = 0, r = this.cleanups.length; n < r; n++)this.cleanups[n](); if (this.scopes) for (n = 0, r = this.scopes.length; n < r; n++)this.scopes[n].stop(!0); if (!this.detached && this.parent && !t) { const s = this.parent.scopes.pop(); s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index) } this.parent = void 0, this._active = !1 } } } function $s(e) { return new il(e) } function Nu(e, t = De) { t && t.active && t.effects.push(e) } function Vu() { return De } function qe(e) { De && De.cleanups.push(e) } let It; class Ns { constructor(t, n, r, s) { this.fn = t, this.trigger = n, this.scheduler = r, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, Nu(this, s) } get dirty() { if (this._dirtyLevel === 2 || this._dirtyLevel === 3) { this._dirtyLevel = 1, wt(); for (let t = 0; t < this._depsLength; t++) { const n = this.deps[t]; if (n.computed && (Bu(n.computed), this._dirtyLevel >= 4)) break } this._dirtyLevel === 1 && (this._dirtyLevel = 0), Ct() } return this._dirtyLevel >= 4 } set dirty(t) { this._dirtyLevel = t ? 4 : 0 } run() { if (this._dirtyLevel = 0, !this.active) return this.fn(); let t = yt, n = It; try { return yt = !0, It = this, this._runnings++, Co(this), this.fn() } finally { So(this), this._runnings--, It = n, yt = t } } stop() { var t; this.active && (Co(this), So(this), (t = this.onStop) == null || t.call(this), this.active = !1) } } function Bu(e) { return e.value } function Co(e) { e._trackId++, e._depsLength = 0 } function So(e) { if (e.deps.length > e._depsLength) { for (let t = e._depsLength; t < e.deps.length; t++)ll(e.deps[t], e); e.deps.length = e._depsLength } } function ll(e, t) { const n = e.get(t); n !== void 0 && t._trackId !== n && (e.delete(t), e.size === 0 && e.cleanup()) } let yt = !0, is = 0; const al = []; function wt() { al.push(yt), yt = !1 } function Ct() { const e = al.pop(); yt = e === void 0 ? !0 : e } function Vs() { is++ } function Bs() { for (is--; !is && ls.length;)ls.shift()() } function ul(e, t, n) { if (t.get(e) !== e._trackId) { t.set(e, e._trackId); const r = e.deps[e._depsLength]; r !== t ? (r && ll(r, e), e.deps[e._depsLength++] = t) : e._depsLength++ } } const ls = []; function cl(e, t, n) { Vs(); for (const r of e.keys()) { let s; r._dirtyLevel < t && (s ?? (s = e.get(r) === r._trackId)) && (r._shouldSchedule || (r._shouldSchedule = r._dirtyLevel === 0), r._dirtyLevel = t), r._shouldSchedule && (s ?? (s = e.get(r) === r._trackId)) && (r.trigger(), (!r._runnings || r.allowRecurse) && r._dirtyLevel !== 2 && (r._shouldSchedule = !1, r.scheduler && ls.push(r.scheduler))) } Bs() } const fl = (e, t) => { const n = new Map; return n.cleanup = e, n.computed = t, n }, sr = new WeakMap, Lt = Symbol(""), as = Symbol(""); function Me(e, t, n) { if (yt && It) { let r = sr.get(e); r || sr.set(e, r = new Map); let s = r.get(n); s || r.set(n, s = fl(() => r.delete(n))), ul(It, s) } } function nt(e, t, n, r, s, o) { const i = sr.get(e); if (!i) return; let l = []; if (t === "clear") l = [...i.values()]; else if (n === "length" && K(e)) { const a = Number(r); i.forEach((u, c) => { (c === "length" || !$t(c) && c >= a) && l.push(u) }) } else switch (n !== void 0 && l.push(i.get(n)), t) { case "add": K(e) ? Fs(n) && l.push(i.get("length")) : (l.push(i.get(Lt)), qt(e) && l.push(i.get(as))); break; case "delete": K(e) || (l.push(i.get(Lt)), qt(e) && l.push(i.get(as))); break; case "set": qt(e) && l.push(i.get(Lt)); break }Vs(); for (const a of l) a && cl(a, 4); Bs() } function Hu(e, t) { var n; return (n = sr.get(e)) == null ? void 0 : n.get(t) } const ju = Is("__proto__,__v_isRef,__isVue"), dl = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter($t)), xo = Wu(); function Wu() { const e = {}; return ["includes", "indexOf", "lastIndexOf"].forEach(t => { e[t] = function (...n) { const r = Q(this); for (let o = 0, i = this.length; o < i; o++)Me(r, "get", o + ""); const s = r[t](...n); return s === -1 || s === !1 ? r[t](...n.map(Q)) : s } }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => { e[t] = function (...n) { wt(), Vs(); const r = Q(this)[t].apply(this, n); return Bs(), Ct(), r } }), e } function zu(e) { $t(e) || (e = String(e)); const t = Q(this); return Me(t, "has", e), t.hasOwnProperty(e) } class ml { constructor(t = !1, n = !1) { this._isReadonly = t, this._isShallow = n } get(t, n, r) { const s = this._isReadonly, o = this._isShallow; if (n === "__v_isReactive") return !s; if (n === "__v_isReadonly") return s; if (n === "__v_isShallow") return o; if (n === "__v_raw") return r === (s ? o ? rc : yl : o ? vl : hl).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(r) ? t : void 0; const i = K(t); if (!s) { if (i && te(xo, n)) return Reflect.get(xo, n, r); if (n === "hasOwnProperty") return zu } const l = Reflect.get(t, n, r); return ($t(n) ? dl.has(n) : ju(n)) || (s || Me(t, "get", n), o) ? l : ve(l) ? i && Fs(n) ? l : l.value : ie(l) ? s ? Pn(l) : Ie(l) : l } } class gl extends ml { constructor(t = !1) { super(!1, t) } set(t, n, r, s) { let o = t[n]; if (!this._isShallow) { const a = pn(o); if (!or(r) && !pn(r) && (o = Q(o), r = Q(r)), !K(t) && ve(o) && !ve(r)) return a ? !1 : (o.value = r, !0) } const i = K(t) && Fs(n) ? Number(n) < t.length : te(t, n), l = Reflect.set(t, n, r, s); return t === Q(s) && (i ? bt(r, o) && nt(t, "set", n, r) : nt(t, "add", n, r)), l } deleteProperty(t, n) { const r = te(t, n); t[n]; const s = Reflect.deleteProperty(t, n); return s && r && nt(t, "delete", n, void 0), s } has(t, n) { const r = Reflect.has(t, n); return (!$t(n) || !dl.has(n)) && Me(t, "has", n), r } ownKeys(t) { return Me(t, "iterate", K(t) ? "length" : Lt), Reflect.ownKeys(t) } } class Uu extends ml { constructor(t = !1) { super(!0, t) } set(t, n) { return !0 } deleteProperty(t, n) { return !0 } } const Ku = new gl, Yu = new Uu, Gu = new gl(!0); const Hs = e => e, Ar = e => Reflect.getPrototypeOf(e); function Vn(e, t, n = !1, r = !1) { e = e.__v_raw; const s = Q(e), o = Q(t); n || (bt(t, o) && Me(s, "get", t), Me(s, "get", o)); const { has: i } = Ar(s), l = r ? Hs : n ? zs : bn; if (i.call(s, t)) return l(e.get(t)); if (i.call(s, o)) return l(e.get(o)); e !== s && e.get(t) } function Bn(e, t = !1) { const n = this.__v_raw, r = Q(n), s = Q(e); return t || (bt(e, s) && Me(r, "has", e), Me(r, "has", s)), e === s ? n.has(e) : n.has(e) || n.has(s) } function Hn(e, t = !1) { return e = e.__v_raw, !t && Me(Q(e), "iterate", Lt), Reflect.get(e, "size", e) } function Eo(e) { e = Q(e); const t = Q(this); return Ar(t).has.call(t, e) || (t.add(e), nt(t, "add", e, e)), this } function To(e, t) { t = Q(t); const n = Q(this), { has: r, get: s } = Ar(n); let o = r.call(n, e); o || (e = Q(e), o = r.call(n, e)); const i = s.call(n, e); return n.set(e, t), o ? bt(t, i) && nt(n, "set", e, t) : nt(n, "add", e, t), this } function Ao(e) { const t = Q(this), { has: n, get: r } = Ar(t); let s = n.call(t, e); s || (e = Q(e), s = n.call(t, e)), r && r.call(t, e); const o = t.delete(e); return s && nt(t, "delete", e, void 0), o } function Oo() { const e = Q(this), t = e.size !== 0, n = e.clear(); return t && nt(e, "clear", void 0, void 0), n } function jn(e, t) { return function (r, s) { const o = this, i = o.__v_raw, l = Q(i), a = t ? Hs : e ? zs : bn; return !e && Me(l, "iterate", Lt), i.forEach((u, c) => r.call(s, a(u), a(c), o)) } } function Wn(e, t, n) { return function (...r) { const s = this.__v_raw, o = Q(s), i = qt(o), l = e === "entries" || e === Symbol.iterator && i, a = e === "keys" && i, u = s[e](...r), c = n ? Hs : t ? zs : bn; return !t && Me(o, "iterate", a ? as : Lt), { next() { const { value: f, done: m } = u.next(); return m ? { value: f, done: m } : { value: l ? [c(f[0]), c(f[1])] : c(f), done: m } }, [Symbol.iterator]() { return this } } } } function at(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function qu() { const e = { get(o) { return Vn(this, o) }, get size() { return Hn(this) }, has: Bn, add: Eo, set: To, delete: Ao, clear: Oo, forEach: jn(!1, !1) }, t = { get(o) { return Vn(this, o, !1, !0) }, get size() { return Hn(this) }, has: Bn, add: Eo, set: To, delete: Ao, clear: Oo, forEach: jn(!1, !0) }, n = { get(o) { return Vn(this, o, !0) }, get size() { return Hn(this, !0) }, has(o) { return Bn.call(this, o, !0) }, add: at("add"), set: at("set"), delete: at("delete"), clear: at("clear"), forEach: jn(!0, !1) }, r = { get(o) { return Vn(this, o, !0, !0) }, get size() { return Hn(this, !0) }, has(o) { return Bn.call(this, o, !0) }, add: at("add"), set: at("set"), delete: at("delete"), clear: at("clear"), forEach: jn(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(o => { e[o] = Wn(o, !1, !1), n[o] = Wn(o, !0, !1), t[o] = Wn(o, !1, !0), r[o] = Wn(o, !0, !0) }), [e, n, t, r] } const [Zu, Xu, Ju, Qu] = qu(); function js(e, t) { const n = t ? e ? Qu : Ju : e ? Xu : Zu; return (r, s, o) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? r : Reflect.get(te(n, s) && s in r ? n : r, s, o) } const ec = { get: js(!1, !1) }, tc = { get: js(!1, !0) }, nc = { get: js(!0, !1) }; const hl = new WeakMap, vl = new WeakMap, yl = new WeakMap, rc = new WeakMap; function sc(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function oc(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : sc(Au(e)) } function Ie(e) { return pn(e) ? e : Ws(e, !1, Ku, ec, hl) } function ic(e) { return Ws(e, !1, Gu, tc, vl) } function Pn(e) { return Ws(e, !0, Yu, nc, yl) } function Ws(e, t, n, r, s) { if (!ie(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const o = s.get(e); if (o) return o; const i = oc(e); if (i === 0) return e; const l = new Proxy(e, i === 2 ? r : n); return s.set(e, l), l } function mn(e) { return pn(e) ? mn(e.__v_raw) : !!(e && e.__v_isReactive) } function pn(e) { return !!(e && e.__v_isReadonly) } function or(e) { return !!(e && e.__v_isShallow) } function pl(e) { return e ? !!e.__v_raw : !1 } function Q(e) { const t = e && e.__v_raw; return t ? Q(t) : e } function lc(e) { return Object.isExtensible(e) && tl(e, "__v_skip", !0), e } const bn = e => ie(e) ? Ie(e) : e, zs = e => ie(e) ? Pn(e) : e; class bl { constructor(t, n, r, s) { this.getter = t, this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new Ns(() => t(this._value), () => Zn(this, this.effect._dirtyLevel === 2 ? 2 : 3)), this.effect.computed = this, this.effect.active = this._cacheable = !s, this.__v_isReadonly = r } get value() { const t = Q(this); return (!t._cacheable || t.effect.dirty) && bt(t._value, t._value = t.effect.run()) && Zn(t, 4), _l(t), t.effect._dirtyLevel >= 2 && Zn(t, 2), t._value } set value(t) { this._setter(t) } get _dirty() { return this.effect.dirty } set _dirty(t) { this.effect.dirty = t } } function ac(e, t, n = !1) { let r, s; const o = q(e); return o ? (r = e, s = Be) : (r = e.get, s = e.set), new bl(r, s, o || !s, n) } function _l(e) { var t; yt && It && (e = Q(e), ul(It, (t = e.dep) != null ? t : e.dep = fl(() => e.dep = void 0, e instanceof bl ? e : void 0))) } function Zn(e, t = 4, n) { e = Q(e); const r = e.dep; r && cl(r, t) } function ve(e) { return !!(e && e.__v_isRef === !0) } function ce(e) { return wl(e, !1) } function me(e) { return wl(e, !0) } function wl(e, t) { return ve(e) ? e : new uc(e, t) } class uc { constructor(t, n) { this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? t : Q(t), this._value = n ? t : bn(t) } get value() { return _l(this), this._value } set value(t) { const n = this.__v_isShallow || or(t) || pn(t); t = n ? t : Q(t), bt(t, this._rawValue) && (this._rawValue = t, this._value = n ? t : bn(t), Zn(this, 4)) } } function vt(e) { return ve(e) ? e.value : e } const cc = { get: (e, t, n) => vt(Reflect.get(e, t, n)), set: (e, t, n, r) => { const s = e[t]; return ve(s) && !ve(n) ? (s.value = n, !0) : Reflect.set(e, t, n, r) } }; function Cl(e) { return mn(e) ? e : new Proxy(e, cc) } function Us(e) { const t = K(e) ? new Array(e.length) : {}; for (const n in e) t[n] = Sl(e, n); return t } class fc { constructor(t, n, r) { this._object = t, this._key = n, this._defaultValue = r, this.__v_isRef = !0 } get value() { const t = this._object[this._key]; return t === void 0 ? this._defaultValue : t } set value(t) { this._object[this._key] = t } get dep() { return Hu(Q(this._object), this._key) } } class dc { constructor(t) { this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0 } get value() { return this._getter() } } function Dt(e, t, n) { return ve(e) ? e : q(e) ? new dc(e) : ie(e) && arguments.length > 1 ? Sl(e, t, n) : ce(e) } function Sl(e, t, n) { const r = e[t]; return ve(r) ? r : new fc(e, t, n) }/**
* @vue/runtime-core v3.4.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function pt(e, t, n, r) { try { return r ? e(...r) : e() } catch (s) { Or(s, t, n) } } function He(e, t, n, r) { if (q(e)) { const s = pt(e, t, n, r); return s && Ji(s) && s.catch(o => { Or(o, t, n) }), s } if (K(e)) { const s = []; for (let o = 0; o < e.length; o++)s.push(He(e[o], t, n, r)); return s } } function Or(e, t, n, r = !0) { const s = t ? t.vnode : null; if (t) { let o = t.parent; const i = t.proxy, l = `https://vuejs.org/error-reference/#runtime-${n}`; for (; o;) { const u = o.ec; if (u) { for (let c = 0; c < u.length; c++)if (u[c](e, i, l) === !1) return } o = o.parent } const a = t.appContext.config.errorHandler; if (a) { wt(), pt(a, null, 10, [e, i, l]), Ct(); return } } mc(e, n, s, r) } function mc(e, t, n, r = !0) { console.error(e) } let _n = !1, us = !1; const Ee = []; let Qe = 0; const Zt = []; let ft = null, Ot = 0; const xl = Promise.resolve(); let Ks = null; function Nt(e) { const t = Ks || xl; return e ? t.then(this ? e.bind(this) : e) : t } function gc(e) { let t = Qe + 1, n = Ee.length; for (; t < n;) { const r = t + n >>> 1, s = Ee[r], o = wn(s); o < e || o === e && s.pre ? t = r + 1 : n = r } return t } function Ys(e) { (!Ee.length || !Ee.includes(e, _n && e.allowRecurse ? Qe + 1 : Qe)) && (e.id == null ? Ee.push(e) : Ee.splice(gc(e.id), 0, e), El()) } function El() { !_n && !us && (us = !0, Ks = xl.then(Al)) } function hc(e) { const t = Ee.indexOf(e); t > Qe && Ee.splice(t, 1) } function vc(e) { K(e) ? Zt.push(...e) : (!ft || !ft.includes(e, e.allowRecurse ? Ot + 1 : Ot)) && Zt.push(e), El() } function ko(e, t, n = _n ? Qe + 1 : 0) { for (; n < Ee.length; n++) { const r = Ee[n]; if (r && r.pre) { if (e && r.id !== e.uid) continue; Ee.splice(n, 1), n--, r() } } } function Tl(e) { if (Zt.length) { const t = [...new Set(Zt)].sort((n, r) => wn(n) - wn(r)); if (Zt.length = 0, ft) { ft.push(...t); return } for (ft = t, Ot = 0; Ot < ft.length; Ot++)ft[Ot](); ft = null, Ot = 0 } } const wn = e => e.id == null ? 1 / 0 : e.id, yc = (e, t) => { const n = wn(e) - wn(t); if (n === 0) { if (e.pre && !t.pre) return -1; if (t.pre && !e.pre) return 1 } return n }; function Al(e) { us = !1, _n = !0, Ee.sort(yc); try { for (Qe = 0; Qe < Ee.length; Qe++) { const t = Ee[Qe]; t && t.active !== !1 && pt(t, null, 14) } } finally { Qe = 0, Ee.length = 0, Tl(), _n = !1, Ks = null, (Ee.length || Zt.length) && Al() } } function pc(e, t, ...n) { if (e.isUnmounted) return; const r = e.vnode.props || ae; let s = n; const o = t.startsWith("update:"), i = o && t.slice(7); if (i && i in r) { const c = `${i === "modelValue" ? "model" : i}Modifiers`, { number: f, trim: m } = r[c] || ae; m && (s = n.map(h => he(h) ? h.trim() : h)), f && (s = n.map(Pu)) } let l, a = r[l = jr(t)] || r[l = jr(Ge(t))]; !a && o && (a = r[l = jr(Qt(t))]), a && He(a, e, 6, s); const u = r[l + "Once"]; if (u) { if (!e.emitted) e.emitted = {}; else if (e.emitted[l]) return; e.emitted[l] = !0, He(u, e, 6, s) } } function Ol(e, t, n = !1) { const r = t.emitsCache, s = r.get(e); if (s !== void 0) return s; const o = e.emits; let i = {}, l = !1; if (!q(e)) { const a = u => { const c = Ol(u, t, !0); c && (l = !0, be(i, c)) }; !n && t.mixins.length && t.mixins.forEach(a), e.extends && a(e.extends), e.mixins && e.mixins.forEach(a) } return !o && !l ? (ie(e) && r.set(e, null), null) : (K(o) ? o.forEach(a => i[a] = null) : be(i, o), ie(e) && r.set(e, i), i) } function kr(e, t) { return !e || !xr(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), te(e, t[0].toLowerCase() + t.slice(1)) || te(e, Qt(t)) || te(e, t)) } let Oe = null, Pr = null; function ir(e) { const t = Oe; return Oe = e, Pr = e && e.type.__scopeId || null, t } function bc(e) { Pr = e } function _c() { Pr = null } function de(e, t = Oe, n) { if (!t || e._n) return e; const r = (...s) => { r._d && Wo(-1); const o = ir(t); let i; try { i = e(...s) } finally { ir(o), r._d && Wo(1) } return i }; return r._n = !0, r._c = !0, r._d = !0, r } function Ur(e) { const { type: t, vnode: n, proxy: r, withProxy: s, propsOptions: [o], slots: i, attrs: l, emit: a, render: u, renderCache: c, props: f, data: m, setupState: h, ctx: b, inheritAttrs: v } = e, L = ir(e); let $, D; try { if (n.shapeFlag & 4) { const W = s || r, U = W; $ = Je(u.call(U, W, c, f, h, m, b)), D = l } else { const W = t; $ = Je(W.length > 1 ? W(f, { attrs: l, slots: i, emit: a }) : W(f, null)), D = t.props ? l : wc(l) } } catch (W) { yn.length = 0, Or(W, e, 1), $ = p(rt) } let F = $; if (D && v !== !1) { const W = Object.keys(D), { shapeFlag: U } = F; W.length && U & 7 && (o && W.some(Ls) && (D = Cc(D, o)), F = _t(F, D)) } return n.dirs && (F = _t(F), F.dirs = F.dirs ? F.dirs.concat(n.dirs) : n.dirs), n.transition && (F.transition = n.transition), $ = F, ir(L), $ } const wc = e => { let t; for (const n in e) (n === "class" || n === "style" || xr(n)) && ((t || (t = {}))[n] = e[n]); return t }, Cc = (e, t) => { const n = {}; for (const r in e) (!Ls(r) || !(r.slice(9) in t)) && (n[r] = e[r]); return n }; function Sc(e, t, n) { const { props: r, children: s, component: o } = e, { props: i, children: l, patchFlag: a } = t, u = o.emitsOptions; if (t.dirs || t.transition) return !0; if (n && a >= 0) { if (a & 1024) return !0; if (a & 16) return r ? Po(r, i, u) : !!i; if (a & 8) { const c = t.dynamicProps; for (let f = 0; f < c.length; f++) { const m = c[f]; if (i[m] !== r[m] && !kr(u, m)) return !0 } } } else return (s || l) && (!l || !l.$stable) ? !0 : r === i ? !1 : r ? i ? Po(r, i, u) : !0 : !!i; return !1 } function Po(e, t, n) { const r = Object.keys(t); if (r.length !== Object.keys(e).length) return !0; for (let s = 0; s < r.length; s++) { const o = r[s]; if (t[o] !== e[o] && !kr(n, o)) return !0 } return !1 } function xc({ vnode: e, parent: t }, n) { for (; t;) { const r = t.subTree; if (r.suspense && r.suspense.activeBranch === e && (r.el = e.el), r === e) (e = t.vnode).el = n, t = t.parent; else break } } const kl = "components", Ec = "directives", Pl = Symbol.for("v-ndc"); function Tc(e) { return he(e) ? Il(kl, e, !1) || e : e || Pl } function Gs(e) { return Il(Ec, e) } function Il(e, t, n = !0, r = !1) { const s = Oe || xe; if (s) { const o = s.type; if (e === kl) { const l = wf(o, !1); if (l && (l === t || l === Ge(t) || l === st(Ge(t)))) return o } const i = Io(s[e] || o[e], t) || Io(s.appContext[e], t); return !i && r ? o : i } } function Io(e, t) { return e && (e[t] || e[Ge(t)] || e[st(Ge(t))]) } const Ac = e => e.__isSuspense; function Oc(e, t) { t && t.pendingBranch ? K(e) ? t.effects.push(...e) : t.effects.push(e) : vc(e) } const kc = Symbol.for("v-scx"), Pc = () => Le(kc); function Vt(e, t) { return qs(e, null, t) } const zn = {}; function oe(e, t, n) { return qs(e, t, n) } function qs(e, t, { immediate: n, deep: r, flush: s, once: o, onTrack: i, onTrigger: l } = ae) { if (t && o) { const A = t; t = (...S) => { A(...S), U() } } const a = xe, u = A => r === !0 ? A : Pt(A, r === !1 ? 1 : void 0); let c, f = !1, m = !1; if (ve(e) ? (c = () => e.value, f = or(e)) : mn(e) ? (c = () => u(e), f = !0) : K(e) ? (m = !0, f = e.some(A => mn(A) || or(A)), c = () => e.map(A => { if (ve(A)) return A.value; if (mn(A)) return u(A); if (q(A)) return pt(A, a, 2) })) : q(e) ? t ? c = () => pt(e, a, 2) : c = () => (h && h(), He(e, a, 3, [b])) : c = Be, t && r) { const A = c; c = () => Pt(A()) } let h, b = A => { h = F.onStop = () => { pt(A, a, 4), h = F.onStop = void 0 } }, v; if (Mr) if (b = Be, t ? n && He(t, a, 3, [c(), m ? [] : void 0, b]) : c(), s === "sync") { const A = Pc(); v = A.__watcherHandles || (A.__watcherHandles = []) } else return Be; let L = m ? new Array(e.length).fill(zn) : zn; const $ = () => { if (!(!F.active || !F.dirty)) if (t) { const A = F.run(); (r || f || (m ? A.some((S, T) => bt(S, L[T])) : bt(A, L))) && (h && h(), He(t, a, 3, [A, L === zn ? void 0 : m && L[0] === zn ? [] : L, b]), L = A) } else F.run() }; $.allowRecurse = !!t; let D; s === "sync" ? D = $ : s === "post" ? D = () => Pe($, a && a.suspense) : ($.pre = !0, a && ($.id = a.uid), D = () => Ys($)); const F = new Ns(c, Be, D), W = Vu(), U = () => { F.stop(), W && Ms(W.effects, F) }; return t ? n ? $() : L = F.run() : s === "post" ? Pe(F.run.bind(F), a && a.suspense) : F.run(), v && v.push(U), U } function Ic(e, t, n) { const r = this.proxy, s = he(e) ? e.includes(".") ? Ll(r, e) : () => r[e] : e.bind(r, r); let o; q(t) ? o = t : (o = t.handler, n = t); const i = Mn(this), l = qs(s, o.bind(r), n); return i(), l } function Ll(e, t) { const n = t.split("."); return () => { let r = e; for (let s = 0; s < n.length && r; s++)r = r[n[s]]; return r } } function Pt(e, t, n = 0, r) { if (!ie(e) || e.__v_skip) return e; if (t && t > 0) { if (n >= t) return e; n++ } if (r = r || new Set, r.has(e)) return e; if (r.add(e), ve(e)) Pt(e.value, t, n, r); else if (K(e)) for (let s = 0; s < e.length; s++)Pt(e[s], t, n, r); else if (Xi(e) || qt(e)) e.forEach(s => { Pt(s, t, n, r) }); else if (el(e)) for (const s in e) Pt(e[s], t, n, r); return e } function lr(e, t) { if (Oe === null) return e; const n = Fr(Oe) || Oe.proxy, r = e.dirs || (e.dirs = []); for (let s = 0; s < t.length; s++) { let [o, i, l, a = ae] = t[s]; o && (q(o) && (o = { mounted: o, updated: o }), o.deep && Pt(i), r.push({ dir: o, instance: n, value: i, oldValue: void 0, arg: l, modifiers: a })) } return e } function xt(e, t, n, r) { const s = e.dirs, o = t && t.dirs; for (let i = 0; i < s.length; i++) { const l = s[i]; o && (l.oldValue = o[i].value); let a = l.dir[r]; a && (wt(), He(a, n, 8, [e.el, l, e, t]), Ct()) } } const dt = Symbol("_leaveCb"), Un = Symbol("_enterCb"); function Ml() { const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return In(() => { e.isMounted = !0 }), Bt(() => { e.isUnmounting = !0 }), e } const Ve = [Function, Array], Fl = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: Ve, onEnter: Ve, onAfterEnter: Ve, onEnterCancelled: Ve, onBeforeLeave: Ve, onLeave: Ve, onAfterLeave: Ve, onLeaveCancelled: Ve, onBeforeAppear: Ve, onAppear: Ve, onAfterAppear: Ve, onAppearCancelled: Ve }, Lc = { name: "BaseTransition", props: Fl, setup(e, { slots: t }) { const n = no(), r = Ml(); return () => { const s = t.default && Zs(t.default(), !0); if (!s || !s.length) return; let o = s[0]; if (s.length > 1) { for (const m of s) if (m.type !== rt) { o = m; break } } const i = Q(e), { mode: l } = i; if (r.isLeaving) return Kr(o); const a = Lo(o); if (!a) return Kr(o); const u = Cn(a, i, r, n); Sn(a, u); const c = n.subTree, f = c && Lo(c); if (f && f.type !== rt && !kt(a, f)) { const m = Cn(f, i, r, n); if (Sn(f, m), l === "out-in") return r.isLeaving = !0, m.afterLeave = () => { r.isLeaving = !1, n.update.active !== !1 && (n.effect.dirty = !0, n.update()) }, Kr(o); l === "in-out" && a.type !== rt && (m.delayLeave = (h, b, v) => { const L = Dl(r, f); L[String(f.key)] = f, h[dt] = () => { b(), h[dt] = void 0, delete u.delayedLeave }, u.delayedLeave = v }) } return o } } }, Mc = Lc; function Dl(e, t) { const { leavingVNodes: n } = e; let r = n.get(t.type); return r || (r = Object.create(null), n.set(t.type, r)), r } function Cn(e, t, n, r) { const { appear: s, mode: o, persisted: i = !1, onBeforeEnter: l, onEnter: a, onAfterEnter: u, onEnterCancelled: c, onBeforeLeave: f, onLeave: m, onAfterLeave: h, onLeaveCancelled: b, onBeforeAppear: v, onAppear: L, onAfterAppear: $, onAppearCancelled: D } = t, F = String(e.key), W = Dl(n, e), U = (T, V) => { T && He(T, r, 9, V) }, A = (T, V) => { const B = V[1]; U(T, V), K(T) ? T.every(H => H.length <= 1) && B() : T.length <= 1 && B() }, S = { mode: o, persisted: i, beforeEnter(T) { let V = l; if (!n.isMounted) if (s) V = v || l; else return; T[dt] && T[dt](!0); const B = W[F]; B && kt(e, B) && B.el[dt] && B.el[dt](), U(V, [T]) }, enter(T) { let V = a, B = u, H = c; if (!n.isMounted) if (s) V = L || a, B = $ || u, H = D || c; else return; let _ = !1; const P = T[Un] = N => { _ || (_ = !0, N ? U(H, [T]) : U(B, [T]), S.delayedLeave && S.delayedLeave(), T[Un] = void 0) }; V ? A(V, [T, P]) : P() }, leave(T, V) { const B = String(e.key); if (T[Un] && T[Un](!0), n.isUnmounting) return V(); U(f, [T]); let H = !1; const _ = T[dt] = P => { H || (H = !0, V(), P ? U(b, [T]) : U(h, [T]), T[dt] = void 0, W[B] === e && delete W[B]) }; W[B] = e, m ? A(m, [T, _]) : _() }, clone(T) { return Cn(T, t, n, r) } }; return S } function Kr(e) { if (Ir(e)) return e = _t(e), e.children = null, e } function Lo(e) { if (!Ir(e)) return e; const { shapeFlag: t, children: n } = e; if (n) { if (t & 16) return n[0]; if (t & 32 && q(n.default)) return n.default() } } function Sn(e, t) { e.shapeFlag & 6 && e.component ? Sn(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function Zs(e, t = !1, n) { let r = [], s = 0; for (let o = 0; o < e.length; o++) { let i = e[o]; const l = n == null ? i.key : String(n) + String(i.key != null ? i.key : o); i.type === we ? (i.patchFlag & 128 && s++, r = r.concat(Zs(i.children, t, l))) : (t || i.type !== rt) && r.push(l != null ? _t(i, { key: l }) : i) } if (s > 1) for (let o = 0; o < r.length; o++)r[o].patchFlag = -2; return r }/*! #__NO_SIDE_EFFECTS__ */function Fc(e, t) { return q(e) ? be({ name: e.name }, t, { setup: e }) : e } const Xn = e => !!e.type.__asyncLoader, Ir = e => e.type.__isKeepAlive; function Rl(e, t) { Nl(e, "a", t) } function $l(e, t) { Nl(e, "da", t) } function Nl(e, t, n = xe) { const r = e.__wdc || (e.__wdc = () => { let s = n; for (; s;) { if (s.isDeactivated) return; s = s.parent } return e() }); if (Lr(t, r, n), n) { let s = n.parent; for (; s && s.parent;)Ir(s.parent.vnode) && Dc(r, t, n, s), s = s.parent } } function Dc(e, t, n, r) { const s = Lr(t, e, r, !0); Hl(() => { Ms(r[t], s) }, n) } function Lr(e, t, n = xe, r = !1) { if (n) { const s = n[e] || (n[e] = []), o = t.__weh || (t.__weh = (...i) => { if (n.isUnmounted) return; wt(); const l = Mn(n), a = He(t, n, e, i); return l(), Ct(), a }); return r ? s.unshift(o) : s.push(o), o } } const ot = e => (t, n = xe) => (!Mr || e === "sp") && Lr(e, (...r) => t(...r), n), Vl = ot("bm"), In = ot("m"), Rc = ot("bu"), Bl = ot("u"), Bt = ot("bum"), Hl = ot("um"), $c = ot("sp"), Nc = ot("rtg"), Vc = ot("rtc"); function Bc(e, t = xe) { Lr("ec", e, t) } function Hc(e, t, n, r) { let s; const o = n && n[r]; if (K(e) || he(e)) { s = new Array(e.length); for (let i = 0, l = e.length; i < l; i++)s[i] = t(e[i], i, void 0, o && o[i]) } else if (typeof e == "number") { s = new Array(e); for (let i = 0; i < e; i++)s[i] = t(i + 1, i, void 0, o && o[i]) } else if (ie(e)) if (e[Symbol.iterator]) s = Array.from(e, (i, l) => t(i, l, void 0, o && o[l])); else { const i = Object.keys(e); s = new Array(i.length); for (let l = 0, a = i.length; l < a; l++) { const u = i[l]; s[l] = t(e[u], u, l, o && o[l]) } } else s = []; return n && (n[r] = s), s } const cs = e => e ? na(e) ? Fr(e) || e.proxy : cs(e.parent) : null, gn = be(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => cs(e.parent), $root: e => cs(e.root), $emit: e => e.emit, $options: e => Xs(e), $forceUpdate: e => e.f || (e.f = () => { e.effect.dirty = !0, Ys(e.update) }), $nextTick: e => e.n || (e.n = Nt.bind(e.proxy)), $watch: e => Ic.bind(e) }), Yr = (e, t) => e !== ae && !e.__isScriptSetup && te(e, t), jc = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: n, setupState: r, data: s, props: o, accessCache: i, type: l, appContext: a } = e; let u; if (t[0] !== "$") { const h = i[t]; if (h !== void 0) switch (h) { case 1: return r[t]; case 2: return s[t]; case 4: return n[t]; case 3: return o[t] } else { if (Yr(r, t)) return i[t] = 1, r[t]; if (s !== ae && te(s, t)) return i[t] = 2, s[t]; if ((u = e.propsOptions[0]) && te(u, t)) return i[t] = 3, o[t]; if (n !== ae && te(n, t)) return i[t] = 4, n[t]; fs && (i[t] = 0) } } const c = gn[t]; let f, m; if (c) return t === "$attrs" && Me(e.attrs, "get", ""), c(e); if ((f = l.__cssModules) && (f = f[t])) return f; if (n !== ae && te(n, t)) return i[t] = 4, n[t]; if (m = a.config.globalProperties, te(m, t)) return m[t] }, set({ _: e }, t, n) { const { data: r, setupState: s, ctx: o } = e; return Yr(s, t) ? (s[t] = n, !0) : r !== ae && te(r, t) ? (r[t] = n, !0) : te(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (o[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: r, appContext: s, propsOptions: o } }, i) { let l; return !!n[i] || e !== ae && te(e, i) || Yr(t, i) || (l = o[0]) && te(l, i) || te(r, i) || te(gn, i) || te(s.config.globalProperties, i) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : te(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; function Mo(e) { return K(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e } let fs = !0; function Wc(e) { const t = Xs(e), n = e.proxy, r = e.ctx; fs = !1, t.beforeCreate && Fo(t.beforeCreate, e, "bc"); const { data: s, computed: o, methods: i, watch: l, provide: a, inject: u, created: c, beforeMount: f, mounted: m, beforeUpdate: h, updated: b, activated: v, deactivated: L, beforeDestroy: $, beforeUnmount: D, destroyed: F, unmounted: W, render: U, renderTracked: A, renderTriggered: S, errorCaptured: T, serverPrefetch: V, expose: B, inheritAttrs: H, components: _, directives: P, filters: N } = t; if (u && zc(u, r, null), i) for (const ne in i) { const Y = i[ne]; q(Y) && (r[ne] = Y.bind(n)) } if (s) { const ne = s.call(n, n); ie(ne) && (e.data = Ie(ne)) } if (fs = !0, o) for (const ne in o) { const Y = o[ne], fe = q(Y) ? Y.bind(n, n) : q(Y.get) ? Y.get.bind(n, n) : Be, We = !q(Y) && q(Y.set) ? Y.set.bind(n) : Be, Se = E({ get: fe, set: We }); Object.defineProperty(r, ne, { enumerable: !0, configurable: !0, get: () => Se.value, set: pe => Se.value = pe }) } if (l) for (const ne in l) jl(l[ne], r, n, ne); if (a) { const ne = q(a) ? a.call(n) : a; Reflect.ownKeys(ne).forEach(Y => { Ht(Y, ne[Y]) }) } c && Fo(c, e, "c"); function ee(ne, Y) { K(Y) ? Y.forEach(fe => ne(fe.bind(n))) : Y && ne(Y.bind(n)) } if (ee(Vl, f), ee(In, m), ee(Rc, h), ee(Bl, b), ee(Rl, v), ee($l, L), ee(Bc, T), ee(Vc, A), ee(Nc, S), ee(Bt, D), ee(Hl, W), ee($c, V), K(B)) if (B.length) { const ne = e.exposed || (e.exposed = {}); B.forEach(Y => { Object.defineProperty(ne, Y, { get: () => n[Y], set: fe => n[Y] = fe }) }) } else e.exposed || (e.exposed = {}); U && e.render === Be && (e.render = U), H != null && (e.inheritAttrs = H), _ && (e.components = _), P && (e.directives = P) } function zc(e, t, n = Be) { K(e) && (e = ds(e)); for (const r in e) { const s = e[r]; let o; ie(s) ? "default" in s ? o = Le(s.from || r, s.default, !0) : o = Le(s.from || r) : o = Le(s), ve(o) ? Object.defineProperty(t, r, { enumerable: !0, configurable: !0, get: () => o.value, set: i => o.value = i }) : t[r] = o } } function Fo(e, t, n) { He(K(e) ? e.map(r => r.bind(t.proxy)) : e.bind(t.proxy), t, n) } function jl(e, t, n, r) { const s = r.includes(".") ? Ll(n, r) : () => n[r]; if (he(e)) { const o = t[e]; q(o) && oe(s, o) } else if (q(e)) oe(s, e.bind(n)); else if (ie(e)) if (K(e)) e.forEach(o => jl(o, t, n, r)); else { const o = q(e.handler) ? e.handler.bind(n) : t[e.handler]; q(o) && oe(s, o, e) } } function Xs(e) { const t = e.type, { mixins: n, extends: r } = t, { mixins: s, optionsCache: o, config: { optionMergeStrategies: i } } = e.appContext, l = o.get(t); let a; return l ? a = l : !s.length && !n && !r ? a = t : (a = {}, s.length && s.forEach(u => ar(a, u, i, !0)), ar(a, t, i)), ie(t) && o.set(t, a), a } function ar(e, t, n, r = !1) { const { mixins: s, extends: o } = t; o && ar(e, o, n, !0), s && s.forEach(i => ar(e, i, n, !0)); for (const i in t) if (!(r && i === "expose")) { const l = Uc[i] || n && n[i]; e[i] = l ? l(e[i], t[i]) : t[i] } return e } const Uc = { data: Do, props: Ro, emits: Ro, methods: cn, computed: cn, beforeCreate: Ae, created: Ae, beforeMount: Ae, mounted: Ae, beforeUpdate: Ae, updated: Ae, beforeDestroy: Ae, beforeUnmount: Ae, destroyed: Ae, unmounted: Ae, activated: Ae, deactivated: Ae, errorCaptured: Ae, serverPrefetch: Ae, components: cn, directives: cn, watch: Yc, provide: Do, inject: Kc }; function Do(e, t) { return t ? e ? function () { return be(q(e) ? e.call(this, this) : e, q(t) ? t.call(this, this) : t) } : t : e } function Kc(e, t) { return cn(ds(e), ds(t)) } function ds(e) { if (K(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function Ae(e, t) { return e ? [...new Set([].concat(e, t))] : t } function cn(e, t) { return e ? be(Object.create(null), e, t) : t } function Ro(e, t) { return e ? K(e) && K(t) ? [...new Set([...e, ...t])] : be(Object.create(null), Mo(e), Mo(t ?? {})) : t } function Yc(e, t) { if (!e) return t; if (!t) return e; const n = be(Object.create(null), e); for (const r in t) n[r] = Ae(e[r], t[r]); return n } function Wl() { return { app: null, config: { isNativeTag: Eu, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let Gc = 0; function qc(e, t) { return function (r, s = null) { q(r) || (r = be({}, r)), s != null && !ie(s) && (s = null); const o = Wl(), i = new WeakSet; let l = !1; const a = o.app = { _uid: Gc++, _component: r, _props: s, _container: null, _context: o, _instance: null, version: Sf, get config() { return o.config }, set config(u) { }, use(u, ...c) { return i.has(u) || (u && q(u.install) ? (i.add(u), u.install(a, ...c)) : q(u) && (i.add(u), u(a, ...c))), a }, mixin(u) { return o.mixins.includes(u) || o.mixins.push(u), a }, component(u, c) { return c ? (o.components[u] = c, a) : o.components[u] }, directive(u, c) { return c ? (o.directives[u] = c, a) : o.directives[u] }, mount(u, c, f) { if (!l) { const m = p(r, s); return m.appContext = o, f === !0 ? f = "svg" : f === !1 && (f = void 0), c && t ? t(m, u) : e(m, u, f), l = !0, a._container = u, u.__vue_app__ = a, Fr(m.component) || m.component.proxy } }, unmount() { l && (e(null, a._container), delete a._container.__vue_app__) }, provide(u, c) { return o.provides[u] = c, a }, runWithContext(u) { const c = hn; hn = a; try { return u() } finally { hn = c } } }; return a } } let hn = null; function Ht(e, t) { if (xe) { let n = xe.provides; const r = xe.parent && xe.parent.provides; r === n && (n = xe.provides = Object.create(r)), n[e] = t } } function Le(e, t, n = !1) { const r = xe || Oe; if (r || hn) { const s = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : hn._context.provides; if (s && e in s) return s[e]; if (arguments.length > 1) return n && q(t) ? t.call(r && r.proxy) : t } } const zl = {}, Ul = () => Object.create(zl), Kl = e => Object.getPrototypeOf(e) === zl; function Zc(e, t, n, r = !1) { const s = {}, o = Ul(); e.propsDefaults = Object.create(null), Yl(e, t, s, o); for (const i in e.propsOptions[0]) i in s || (s[i] = void 0); n ? e.props = r ? s : ic(s) : e.type.props ? e.props = s : e.props = o, e.attrs = o } function Xc(e, t, n, r) { const { props: s, attrs: o, vnode: { patchFlag: i } } = e, l = Q(s), [a] = e.propsOptions; let u = !1; if ((r || i > 0) && !(i & 16)) { if (i & 8) { const c = e.vnode.dynamicProps; for (let f = 0; f < c.length; f++) { let m = c[f]; if (kr(e.emitsOptions, m)) continue; const h = t[m]; if (a) if (te(o, m)) h !== o[m] && (o[m] = h, u = !0); else { const b = Ge(m); s[b] = ms(a, l, b, h, e, !1) } else h !== o[m] && (o[m] = h, u = !0) } } } else { Yl(e, t, s, o) && (u = !0); let c; for (const f in l) (!t || !te(t, f) && ((c = Qt(f)) === f || !te(t, c))) && (a ? n && (n[f] !== void 0 || n[c] !== void 0) && (s[f] = ms(a, l, f, void 0, e, !0)) : delete s[f]); if (o !== l) for (const f in o) (!t || !te(t, f)) && (delete o[f], u = !0) } u && nt(e.attrs, "set", "") } function Yl(e, t, n, r) { const [s, o] = e.propsOptions; let i = !1, l; if (t) for (let a in t) { if (dn(a)) continue; const u = t[a]; let c; s && te(s, c = Ge(a)) ? !o || !o.includes(c) ? n[c] = u : (l || (l = {}))[c] = u : kr(e.emitsOptions, a) || (!(a in r) || u !== r[a]) && (r[a] = u, i = !0) } if (o) { const a = Q(n), u = l || ae; for (let c = 0; c < o.length; c++) { const f = o[c]; n[f] = ms(s, a, f, u[f], e, !te(u, f)) } } return i } function ms(e, t, n, r, s, o) { const i = e[n]; if (i != null) { const l = te(i, "default"); if (l && r === void 0) { const a = i.default; if (i.type !== Function && !i.skipFactory && q(a)) { const { propsDefaults: u } = s; if (n in u) r = u[n]; else { const c = Mn(s); r = u[n] = a.call(null, t), c() } } else r = a } i[0] && (o && !l ? r = !1 : i[1] && (r === "" || r === Qt(n)) && (r = !0)) } return r } function Gl(e, t, n = !1) { const r = t.propsCache, s = r.get(e); if (s) return s; const o = e.props, i = {}, l = []; let a = !1; if (!q(e)) { const c = f => { a = !0; const [m, h] = Gl(f, t, !0); be(i, m), h && l.push(...h) }; !n && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c) } if (!o && !a) return ie(e) && r.set(e, Gt), Gt; if (K(o)) for (let c = 0; c < o.length; c++) { const f = Ge(o[c]); $o(f) && (i[f] = ae) } else if (o) for (const c in o) { const f = Ge(c); if ($o(f)) { const m = o[c], h = i[f] = K(m) || q(m) ? { type: m } : be({}, m); if (h) { const b = Bo(Boolean, h.type), v = Bo(String, h.type); h[0] = b > -1, h[1] = v < 0 || b < v, (b > -1 || te(h, "default")) && l.push(f) } } } const u = [i, l]; return ie(e) && r.set(e, u), u } function $o(e) { return e[0] !== "$" && !dn(e) } function No(e) { return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || "" } function Vo(e, t) { return No(e) === No(t) } function Bo(e, t) { return K(t) ? t.findIndex(n => Vo(n, e)) : q(t) && Vo(t, e) ? 0 : -1 } const ql = e => e[0] === "_" || e === "$stable", Js = e => K(e) ? e.map(Je) : [Je(e)], Jc = (e, t, n) => { if (t._n) return t; const r = de((...s) => Js(t(...s)), n); return r._c = !1, r }, Zl = (e, t, n) => { const r = e._ctx; for (const s in e) { if (ql(s)) continue; const o = e[s]; if (q(o)) t[s] = Jc(s, o, r); else if (o != null) { const i = Js(o); t[s] = () => i } } }, Xl = (e, t) => { const n = Js(t); e.slots.default = () => n }, Qc = (e, t) => { const n = e.slots = Ul(); if (e.vnode.shapeFlag & 32) { const r = t._; r ? (be(n, t), tl(n, "_", r)) : Zl(t, n) } else t && Xl(e, t) }, ef = (e, t, n) => { const { vnode: r, slots: s } = e; let o = !0, i = ae; if (r.shapeFlag & 32) { const l = t._; l ? n && l === 1 ? o = !1 : (be(s, t), !n && l === 1 && delete s._) : (o = !t.$stable, Zl(t, s)), i = t } else t && (Xl(e, t), i = { default: 1 }); if (o) for (const l in s) !ql(l) && i[l] == null && delete s[l] }; function gs(e, t, n, r, s = !1) { if (K(e)) { e.forEach((m, h) => gs(m, t && (K(t) ? t[h] : t), n, r, s)); return } if (Xn(r) && !s) return; const o = r.shapeFlag & 4 ? Fr(r.component) || r.component.proxy : r.el, i = s ? null : o, { i: l, r: a } = e, u = t && t.r, c = l.refs === ae ? l.refs = {} : l.refs, f = l.setupState; if (u != null && u !== a && (he(u) ? (c[u] = null, te(f, u) && (f[u] = null)) : ve(u) && (u.value = null)), q(a)) pt(a, l, 12, [i, c]); else { const m = he(a), h = ve(a); if (m || h) { const b = () => { if (e.f) { const v = m ? te(f, a) ? f[a] : c[a] : a.value; s ? K(v) && Ms(v, o) : K(v) ? v.includes(o) || v.push(o) : m ? (c[a] = [o], te(f, a) && (f[a] = c[a])) : (a.value = [o], e.k && (c[e.k] = a.value)) } else m ? (c[a] = i, te(f, a) && (f[a] = i)) : h && (a.value = i, e.k && (c[e.k] = i)) }; i ? (b.id = -1, Pe(b, n)) : b() } } } const Pe = Oc; function tf(e) { return nf(e) } function nf(e, t) { const n = nl(); n.__VUE__ = !0; const { insert: r, remove: s, patchProp: o, createElement: i, createText: l, createComment: a, setText: u, setElementText: c, parentNode: f, nextSibling: m, setScopeId: h = Be, insertStaticContent: b } = e, v = (d, g, y, w = null, C = null, k = null, M = void 0, O = null, I = !!g.dynamicChildren) => { if (d === g) return; d && !kt(d, g) && (w = ze(d), pe(d, C, k, !0), d = null), g.patchFlag === -2 && (I = !1, g.dynamicChildren = null); const { type: x, ref: R, shapeFlag: z } = g; switch (x) { case Ln: L(d, g, y, w); break; case rt: $(d, g, y, w); break; case qr: d == null && D(g, y, w, M); break; case we: _(d, g, y, w, C, k, M, O, I); break; default: z & 1 ? U(d, g, y, w, C, k, M, O, I) : z & 6 ? P(d, g, y, w, C, k, M, O, I) : (z & 64 || z & 128) && x.process(d, g, y, w, C, k, M, O, I, zt) }R != null && C && gs(R, d && d.ref, k, g || d, !g) }, L = (d, g, y, w) => { if (d == null) r(g.el = l(g.children), y, w); else { const C = g.el = d.el; g.children !== d.children && u(C, g.children) } }, $ = (d, g, y, w) => { d == null ? r(g.el = a(g.children || ""), y, w) : g.el = d.el }, D = (d, g, y, w) => { [d.el, d.anchor] = b(d.children, g, y, w, d.el, d.anchor) }, F = ({ el: d, anchor: g }, y, w) => { let C; for (; d && d !== g;)C = m(d), r(d, y, w), d = C; r(g, y, w) }, W = ({ el: d, anchor: g }) => { let y; for (; d && d !== g;)y = m(d), s(d), d = y; s(g) }, U = (d, g, y, w, C, k, M, O, I) => { g.type === "svg" ? M = "svg" : g.type === "math" && (M = "mathml"), d == null ? A(g, y, w, C, k, M, O, I) : V(d, g, C, k, M, O, I) }, A = (d, g, y, w, C, k, M, O) => { let I, x; const { props: R, shapeFlag: z, transition: j, dirs: G } = d; if (I = d.el = i(d.type, k, R && R.is, R), z & 8 ? c(I, d.children) : z & 16 && T(d.children, I, null, w, C, Gr(d, k), M, O), G && xt(d, null, w, "created"), S(I, d, d.scopeId, M, w), R) { for (const se in R) se !== "value" && !dn(se) && o(I, se, null, R[se], k, d.children, w, C, re); "value" in R && o(I, "value", null, R.value, k), (x = R.onVnodeBeforeMount) && Xe(x, w, d) } G && xt(d, null, w, "beforeMount"); const X = rf(C, j); X && j.beforeEnter(I), r(I, g, y), ((x = R && R.onVnodeMounted) || X || G) && Pe(() => { x && Xe(x, w, d), X && j.enter(I), G && xt(d, null, w, "mounted") }, C) }, S = (d, g, y, w, C) => { if (y && h(d, y), w) for (let k = 0; k < w.length; k++)h(d, w[k]); if (C) { let k = C.subTree; if (g === k) { const M = C.vnode; S(d, M, M.scopeId, M.slotScopeIds, C.parent) } } }, T = (d, g, y, w, C, k, M, O, I = 0) => { for (let x = I; x < d.length; x++) { const R = d[x] = O ? mt(d[x]) : Je(d[x]); v(null, R, g, y, w, C, k, M, O) } }, V = (d, g, y, w, C, k, M) => { const O = g.el = d.el; let { patchFlag: I, dynamicChildren: x, dirs: R } = g; I |= d.patchFlag & 16; const z = d.props || ae, j = g.props || ae; let G; if (y && Et(y, !1), (G = j.onVnodeBeforeUpdate) && Xe(G, y, g, d), R && xt(g, d, y, "beforeUpdate"), y && Et(y, !0), x ? B(d.dynamicChildren, x, O, y, w, Gr(g, C), k) : M || Y(d, g, O, null, y, w, Gr(g, C), k, !1), I > 0) { if (I & 16) H(O, g, z, j, y, w, C); else if (I & 2 && z.class !== j.class && o(O, "class", null, j.class, C), I & 4 && o(O, "style", z.style, j.style, C), I & 8) { const X = g.dynamicProps; for (let se = 0; se < X.length; se++) { const ue = X[se], _e = z[ue], Ue = j[ue]; (Ue !== _e || ue === "value") && o(O, ue, _e, Ue, C, d.children, y, w, re) } } I & 1 && d.children !== g.children && c(O, g.children) } else !M && x == null && H(O, g, z, j, y, w, C); ((G = j.onVnodeUpdated) || R) && Pe(() => { G && Xe(G, y, g, d), R && xt(g, d, y, "updated") }, w) }, B = (d, g, y, w, C, k, M) => { for (let O = 0; O < g.length; O++) { const I = d[O], x = g[O], R = I.el && (I.type === we || !kt(I, x) || I.shapeFlag & 70) ? f(I.el) : y; v(I, x, R, null, w, C, k, M, !0) } }, H = (d, g, y, w, C, k, M) => { if (y !== w) { if (y !== ae) for (const O in y) !dn(O) && !(O in w) && o(d, O, y[O], null, M, g.children, C, k, re); for (const O in w) { if (dn(O)) continue; const I = w[O], x = y[O]; I !== x && O !== "value" && o(d, O, x, I, M, g.children, C, k, re) } "value" in w && o(d, "value", y.value, w.value, M) } }, _ = (d, g, y, w, C, k, M, O, I) => { const x = g.el = d ? d.el : l(""), R = g.anchor = d ? d.anchor : l(""); let { patchFlag: z, dynamicChildren: j, slotScopeIds: G } = g; G && (O = O ? O.concat(G) : G), d == null ? (r(x, y, w), r(R, y, w), T(g.children || [], y, R, C, k, M, O, I)) : z > 0 && z & 64 && j && d.dynamicChildren ? (B(d.dynamicChildren, j, y, C, k, M, O), (g.key != null || C && g === C.subTree) && Qs(d, g, !0)) : Y(d, g, y, R, C, k, M, O, I) }, P = (d, g, y, w, C, k, M, O, I) => { g.slotScopeIds = O, d == null ? g.shapeFlag & 512 ? C.ctx.activate(g, y, w, M, I) : N(g, y, w, C, k, M, I) : ye(d, g, I) }, N = (d, g, y, w, C, k, M) => { const O = d.component = vf(d, w, C); if (Ir(d) && (O.ctx.renderer = zt), yf(O), O.asyncDep) { if (C && C.registerDep(O, ee), !d.el) { const I = O.subTree = p(rt); $(null, I, g, y) } } else ee(O, d, g, y, C, k, M) }, ye = (d, g, y) => { const w = g.component = d.component; if (Sc(d, g, y)) if (w.asyncDep && !w.asyncResolved) { ne(w, g, y); return } else w.next = g, hc(w.update), w.effect.dirty = !0, w.update(); else g.el = d.el, w.vnode = g }, ee = (d, g, y, w, C, k, M) => { const O = () => { if (d.isMounted) { let { next: R, bu: z, u: j, parent: G, vnode: X } = d; { const Ut = Jl(d); if (Ut) { R && (R.el = X.el, ne(d, R, M)), Ut.asyncDep.then(() => { d.isUnmounted || O() }); return } } let se = R, ue; Et(d, !1), R ? (R.el = X.el, ne(d, R, M)) : R = X, z && Wr(z), (ue = R.props && R.props.onVnodeBeforeUpdate) && Xe(ue, G, R, X), Et(d, !0); const _e = Ur(d), Ue = d.subTree; d.subTree = _e, v(Ue, _e, f(Ue.el), ze(Ue), d, C, k), R.el = _e.el, se === null && xc(d, _e.el), j && Pe(j, C), (ue = R.props && R.props.onVnodeUpdated) && Pe(() => Xe(ue, G, R, X), C) } else { let R; const { el: z, props: j } = g, { bm: G, m: X, parent: se } = d, ue = Xn(g); if (Et(d, !1), G && Wr(G), !ue && (R = j && j.onVnodeBeforeMount) && Xe(R, se, g), Et(d, !0), z && Hr) { const _e = () => { d.subTree = Ur(d), Hr(z, d.subTree, d, C, null) }; ue ? g.type.__asyncLoader().then(() => !d.isUnmounted && _e()) : _e() } else { const _e = d.subTree = Ur(d); v(null, _e, y, w, d, C, k), g.el = _e.el } if (X && Pe(X, C), !ue && (R = j && j.onVnodeMounted)) { const _e = g; Pe(() => Xe(R, se, _e), C) } (g.shapeFlag & 256 || se && Xn(se.vnode) && se.vnode.shapeFlag & 256) && d.a && Pe(d.a, C), d.isMounted = !0, g = y = w = null } }, I = d.effect = new Ns(O, Be, () => Ys(x), d.scope), x = d.update = () => { I.dirty && I.run() }; x.id = d.uid, Et(d, !0), x() }, ne = (d, g, y) => { g.component = d; const w = d.vnode.props; d.vnode = g, d.next = null, Xc(d, g.props, w, y), ef(d, g.children, y), wt(), ko(d), Ct() }, Y = (d, g, y, w, C, k, M, O, I = !1) => { const x = d && d.children, R = d ? d.shapeFlag : 0, z = g.children, { patchFlag: j, shapeFlag: G } = g; if (j > 0) { if (j & 128) { We(x, z, y, w, C, k, M, O, I); return } else if (j & 256) { fe(x, z, y, w, C, k, M, O, I); return } } G & 8 ? (R & 16 && re(x, C, k), z !== x && c(y, z)) : R & 16 ? G & 16 ? We(x, z, y, w, C, k, M, O, I) : re(x, C, k, !0) : (R & 8 && c(y, ""), G & 16 && T(z, y, w, C, k, M, O, I)) }, fe = (d, g, y, w, C, k, M, O, I) => { d = d || Gt, g = g || Gt; const x = d.length, R = g.length, z = Math.min(x, R); let j; for (j = 0; j < z; j++) { const G = g[j] = I ? mt(g[j]) : Je(g[j]); v(d[j], G, y, null, C, k, M, O, I) } x > R ? re(d, C, k, !0, !1, z) : T(g, y, w, C, k, M, O, I, z) }, We = (d, g, y, w, C, k, M, O, I) => { let x = 0; const R = g.length; let z = d.length - 1, j = R - 1; for (; x <= z && x <= j;) { const G = d[x], X = g[x] = I ? mt(g[x]) : Je(g[x]); if (kt(G, X)) v(G, X, y, null, C, k, M, O, I); else break; x++ } for (; x <= z && x <= j;) { const G = d[z], X = g[j] = I ? mt(g[j]) : Je(g[j]); if (kt(G, X)) v(G, X, y, null, C, k, M, O, I); else break; z--, j-- } if (x > z) { if (x <= j) { const G = j + 1, X = G < R ? g[G].el : w; for (; x <= j;)v(null, g[x] = I ? mt(g[x]) : Je(g[x]), y, X, C, k, M, O, I), x++ } } else if (x > j) for (; x <= z;)pe(d[x], C, k, !0), x++; else { const G = x, X = x, se = new Map; for (x = X; x <= j; x++) { const Fe = g[x] = I ? mt(g[x]) : Je(g[x]); Fe.key != null && se.set(Fe.key, x) } let ue, _e = 0; const Ue = j - X + 1; let Ut = !1, po = 0; const nn = new Array(Ue); for (x = 0; x < Ue; x++)nn[x] = 0; for (x = G; x <= z; x++) { const Fe = d[x]; if (_e >= Ue) { pe(Fe, C, k, !0); continue } let Ze; if (Fe.key != null) Ze = se.get(Fe.key); else for (ue = X; ue <= j; ue++)if (nn[ue - X] === 0 && kt(Fe, g[ue])) { Ze = ue; break } Ze === void 0 ? pe(Fe, C, k, !0) : (nn[Ze - X] = x + 1, Ze >= po ? po = Ze : Ut = !0, v(Fe, g[Ze], y, null, C, k, M, O, I), _e++) } const bo = Ut ? sf(nn) : Gt; for (ue = bo.length - 1, x = Ue - 1; x >= 0; x--) { const Fe = X + x, Ze = g[Fe], _o = Fe + 1 < R ? g[Fe + 1].el : w; nn[x] === 0 ? v(null, Ze, y, _o, C, k, M, O, I) : Ut && (ue < 0 || x !== bo[ue] ? Se(Ze, y, _o, 2) : ue--) } } }, Se = (d, g, y, w, C = null) => { const { el: k, type: M, transition: O, children: I, shapeFlag: x } = d; if (x & 6) { Se(d.component.subTree, g, y, w); return } if (x & 128) { d.suspense.move(g, y, w); return } if (x & 64) { M.move(d, g, y, zt); return } if (M === we) { r(k, g, y); for (let z = 0; z < I.length; z++)Se(I[z], g, y, w); r(d.anchor, g, y); return } if (M === qr) { F(d, g, y); return } if (w !== 2 && x & 1 && O) if (w === 0) O.beforeEnter(k), r(k, g, y), Pe(() => O.enter(k), C); else { const { leave: z, delayLeave: j, afterLeave: G } = O, X = () => r(k, g, y), se = () => { z(k, () => { X(), G && G() }) }; j ? j(k, X, se) : se() } else r(k, g, y) }, pe = (d, g, y, w = !1, C = !1) => { const { type: k, props: M, ref: O, children: I, dynamicChildren: x, shapeFlag: R, patchFlag: z, dirs: j } = d; if (O != null && gs(O, null, y, d, !0), R & 256) { g.ctx.deactivate(d); return } const G = R & 1 && j, X = !Xn(d); let se; if (X && (se = M && M.onVnodeBeforeUnmount) && Xe(se, g, d), R & 6) le(d.component, y, w); else { if (R & 128) { d.suspense.unmount(y, w); return } G && xt(d, null, g, "beforeUnmount"), R & 64 ? d.type.remove(d, g, y, C, zt, w) : x && (k !== we || z > 0 && z & 64) ? re(x, g, y, !1, !0) : (k === we && z & 384 || !C && R & 16) && re(I, g, y), w && lt(d) } (X && (se = M && M.onVnodeUnmounted) || G) && Pe(() => { se && Xe(se, g, d), G && xt(d, null, g, "unmounted") }, y) }, lt = d => { const { type: g, el: y, anchor: w, transition: C } = d; if (g === we) { tn(y, w); return } if (g === qr) { W(d); return } const k = () => { s(y), C && !C.persisted && C.afterLeave && C.afterLeave() }; if (d.shapeFlag & 1 && C && !C.persisted) { const { leave: M, delayLeave: O } = C, I = () => M(y, k); O ? O(d.el, k, I) : I() } else k() }, tn = (d, g) => { let y; for (; d !== g;)y = m(d), s(d), d = y; s(g) }, le = (d, g, y) => { const { bum: w, scope: C, update: k, subTree: M, um: O } = d; w && Wr(w), C.stop(), k && (k.active = !1, pe(M, d, g, y)), O && Pe(O, g), Pe(() => { d.isUnmounted = !0 }, g), g && g.pendingBranch && !g.isUnmounted && d.asyncDep && !d.asyncResolved && d.suspenseId === g.pendingId && (g.deps--, g.deps === 0 && g.resolve()) }, re = (d, g, y, w = !1, C = !1, k = 0) => { for (let M = k; M < d.length; M++)pe(d[M], g, y, w, C) }, ze = d => d.shapeFlag & 6 ? ze(d.component.subTree) : d.shapeFlag & 128 ? d.suspense.next() : m(d.anchor || d.el); let Vr = !1; const yo = (d, g, y) => { d == null ? g._vnode && pe(g._vnode, null, null, !0) : v(g._vnode || null, d, g, null, null, null, y), Vr || (Vr = !0, ko(), Tl(), Vr = !1), g._vnode = d }, zt = { p: v, um: pe, m: Se, r: lt, mt: N, mc: T, pc: Y, pbc: B, n: ze, o: e }; let Br, Hr; return t && ([Br, Hr] = t(zt)), { render: yo, hydrate: Br, createApp: qc(yo, Br) } } function Gr({ type: e, props: t }, n) { return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n } function Et({ effect: e, update: t }, n) { e.allowRecurse = t.allowRecurse = n } function rf(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function Qs(e, t, n = !1) { const r = e.children, s = t.children; if (K(r) && K(s)) for (let o = 0; o < r.length; o++) { const i = r[o]; let l = s[o]; l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = s[o] = mt(s[o]), l.el = i.el), n || Qs(i, l)), l.type === Ln && (l.el = i.el) } } function sf(e) { const t = e.slice(), n = [0]; let r, s, o, i, l; const a = e.length; for (r = 0; r < a; r++) { const u = e[r]; if (u !== 0) { if (s = n[n.length - 1], e[s] < u) { t[r] = s, n.push(r); continue } for (o = 0, i = n.length - 1; o < i;)l = o + i >> 1, e[n[l]] < u ? o = l + 1 : i = l; u < e[n[o]] && (o > 0 && (t[r] = n[o - 1]), n[o] = r) } } for (o = n.length, i = n[o - 1]; o-- > 0;)n[o] = i, i = t[i]; return n } function Jl(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : Jl(t) } const of = e => e.__isTeleport, vn = e => e && (e.disabled || e.disabled === ""), Ho = e => typeof SVGElement < "u" && e instanceof SVGElement, jo = e => typeof MathMLElement == "function" && e instanceof MathMLElement, hs = (e, t) => { const n = e && e.to; return he(n) ? t ? t(n) : null : n }, lf = { name: "Teleport", __isTeleport: !0, process(e, t, n, r, s, o, i, l, a, u) { const { mc: c, pc: f, pbc: m, o: { insert: h, querySelector: b, createText: v, createComment: L } } = u, $ = vn(t.props); let { shapeFlag: D, children: F, dynamicChildren: W } = t; if (e == null) { const U = t.el = v(""), A = t.anchor = v(""); h(U, n, r), h(A, n, r); const S = t.target = hs(t.props, b), T = t.targetAnchor = v(""); S && (h(T, S), i === "svg" || Ho(S) ? i = "svg" : (i === "mathml" || jo(S)) && (i = "mathml")); const V = (B, H) => { D & 16 && c(F, B, H, s, o, i, l, a) }; $ ? V(n, A) : S && V(S, T) } else { t.el = e.el; const U = t.anchor = e.anchor, A = t.target = e.target, S = t.targetAnchor = e.targetAnchor, T = vn(e.props), V = T ? n : A, B = T ? U : S; if (i === "svg" || Ho(A) ? i = "svg" : (i === "mathml" || jo(A)) && (i = "mathml"), W ? (m(e.dynamicChildren, W, V, s, o, i, l), Qs(e, t, !0)) : a || f(e, t, V, B, s, o, i, l, !1), $) T ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Kn(t, n, U, u, 1); else if ((t.props && t.props.to) !== (e.props && e.props.to)) { const H = t.target = hs(t.props, b); H && Kn(t, H, null, u, 0) } else T && Kn(t, A, S, u, 1) } Ql(t) }, remove(e, t, n, r, { um: s, o: { remove: o } }, i) { const { shapeFlag: l, children: a, anchor: u, targetAnchor: c, target: f, props: m } = e; if (f && o(c), i && o(u), l & 16) { const h = i || !vn(m); for (let b = 0; b < a.length; b++) { const v = a[b]; s(v, t, n, h, !!v.dynamicChildren) } } }, move: Kn, hydrate: af }; function Kn(e, t, n, { o: { insert: r }, m: s }, o = 2) { o === 0 && r(e.targetAnchor, t, n); const { el: i, anchor: l, shapeFlag: a, children: u, props: c } = e, f = o === 2; if (f && r(i, t, n), (!f || vn(c)) && a & 16) for (let m = 0; m < u.length; m++)s(u[m], t, n, 2); f && r(l, t, n) } function af(e, t, n, r, s, o, { o: { nextSibling: i, parentNode: l, querySelector: a } }, u) { const c = t.target = hs(t.props, a); if (c) { const f = c._lpa || c.firstChild; if (t.shapeFlag & 16) if (vn(t.props)) t.anchor = u(i(e), t, l(e), n, r, s, o), t.targetAnchor = f; else { t.anchor = i(e); let m = f; for (; m;)if (m = i(m), m && m.nodeType === 8 && m.data === "teleport anchor") { t.targetAnchor = m, c._lpa = t.targetAnchor && i(t.targetAnchor); break } u(f, t, c, n, r, s, o) } Ql(t) } return t.anchor && i(t.anchor) } const uf = lf; function Ql(e) { const t = e.ctx; if (t && t.ut) { let n = e.children[0].el; for (; n && n !== e.targetAnchor;)n.nodeType === 1 && n.setAttribute("data-v-owner", t.uid), n = n.nextSibling; t.ut() } } const we = Symbol.for("v-fgt"), Ln = Symbol.for("v-txt"), rt = Symbol.for("v-cmt"), qr = Symbol.for("v-stc"), yn = []; let Ke = null; function ur(e = !1) { yn.push(Ke = e ? null : []) } function cf() { yn.pop(), Ke = yn[yn.length - 1] || null } let xn = 1; function Wo(e) { xn += e } function ea(e) { return e.dynamicChildren = xn > 0 ? Ke || Gt : null, cf(), xn > 0 && Ke && Ke.push(e), e } function ff(e, t, n, r, s, o) { return ea(je(e, t, n, r, s, o, !0)) } function eo(e, t, n, r, s) { return ea(p(e, t, n, r, s, !0)) } function vs(e) { return e ? e.__v_isVNode === !0 : !1 } function kt(e, t) { return e.type === t.type && e.key === t.key } const ta = ({ key: e }) => e ?? null, Jn = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? he(e) || ve(e) || q(e) ? { i: Oe, r: e, k: t, f: !!n } : e : null); function je(e, t = null, n = null, r = 0, s = null, o = e === we ? 0 : 1, i = !1, l = !1) { const a = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && ta(t), ref: t && Jn(t), scopeId: Pr, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: o, patchFlag: r, dynamicProps: s, dynamicChildren: null, appContext: null, ctx: Oe }; return l ? (to(a, n), o & 128 && e.normalize(a)) : n && (a.shapeFlag |= he(n) ? 8 : 16), xn > 0 && !i && Ke && (a.patchFlag > 0 || o & 6) && a.patchFlag !== 32 && Ke.push(a), a } const p = df; function df(e, t = null, n = null, r = 0, s = null, o = !1) { if ((!e || e === Pl) && (e = rt), vs(e)) { const l = _t(e, t, !0); return n && to(l, n), xn > 0 && !o && Ke && (l.shapeFlag & 6 ? Ke[Ke.indexOf(e)] = l : Ke.push(l)), l.patchFlag |= -2, l } if (Cf(e) && (e = e.__vccOpts), t) { t = mf(t); let { class: l, style: a } = t; l && !he(l) && (t.class = Rs(l)), ie(a) && (pl(a) && !K(a) && (a = be({}, a)), t.style = Ds(a)) } const i = he(e) ? 1 : Ac(e) ? 128 : of(e) ? 64 : ie(e) ? 4 : q(e) ? 2 : 0; return je(e, t, n, r, s, i, o, !0) } function mf(e) { return e ? pl(e) || Kl(e) ? be({}, e) : e : null } function _t(e, t, n = !1) { const { props: r, ref: s, patchFlag: o, children: i } = e, l = t ? Ye(r || {}, t) : r; return { __v_isVNode: !0, __v_skip: !0, type: e.type, props: l, key: l && ta(l), ref: t && t.ref ? n && s ? K(s) ? s.concat(Jn(t)) : [s, Jn(t)] : Jn(t) : s, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: i, target: e.target, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== we ? o === -1 ? 16 : o | 16 : o, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: e.transition, component: e.component, suspense: e.suspense, ssContent: e.ssContent && _t(e.ssContent), ssFallback: e.ssFallback && _t(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce } } function ht(e = " ", t = 0) { return p(Ln, null, e, t) } function Je(e) { return e == null || typeof e == "boolean" ? p(rt) : K(e) ? p(we, null, e.slice()) : typeof e == "object" ? mt(e) : p(Ln, null, String(e)) } function mt(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : _t(e) } function to(e, t) { let n = 0; const { shapeFlag: r } = e; if (t == null) t = null; else if (K(t)) n = 16; else if (typeof t == "object") if (r & 65) { const s = t.default; s && (s._c && (s._d = !1), to(e, s()), s._c && (s._d = !0)); return } else { n = 32; const s = t._; !s && !Kl(t) ? t._ctx = Oe : s === 3 && Oe && (Oe.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else q(t) ? (t = { default: t, _ctx: Oe }, n = 32) : (t = String(t), r & 64 ? (n = 16, t = [ht(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function Ye(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const r = e[n]; for (const s in r) if (s === "class") t.class !== r.class && (t.class = Rs([t.class, r.class])); else if (s === "style") t.style = Ds([t.style, r.style]); else if (xr(s)) { const o = t[s], i = r[s]; i && o !== i && !(K(o) && o.includes(i)) && (t[s] = o ? [].concat(o, i) : i) } else s !== "" && (t[s] = r[s]) } return t } function Xe(e, t, n, r = null) { He(e, t, 7, [n, r]) } const gf = Wl(); let hf = 0; function vf(e, t, n) { const r = e.type, s = (t ? t.appContext : e.appContext) || gf, o = { uid: hf++, vnode: e, type: r, parent: t, appContext: s, root: null, next: null, subTree: null, effect: null, update: null, scope: new il(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(s.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: Gl(r, s), emitsOptions: Ol(r, s), emit: null, emitted: null, propsDefaults: ae, inheritAttrs: r.inheritAttrs, ctx: ae, data: ae, props: ae, attrs: ae, slots: ae, refs: ae, setupState: ae, setupContext: null, attrsProxy: null, slotsProxy: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return o.ctx = { _: o }, o.root = t ? t.root : o, o.emit = pc.bind(null, o), e.ce && e.ce(o), o } let xe = null; const no = () => xe || Oe; let cr, ys; { const e = nl(), t = (n, r) => { let s; return (s = e[n]) || (s = e[n] = []), s.push(r), o => { s.length > 1 ? s.forEach(i => i(o)) : s[0](o) } }; cr = t("__VUE_INSTANCE_SETTERS__", n => xe = n), ys = t("__VUE_SSR_SETTERS__", n => Mr = n) } const Mn = e => { const t = xe; return cr(e), e.scope.on(), () => { e.scope.off(), cr(t) } }, zo = () => { xe && xe.scope.off(), cr(null) }; function na(e) { return e.vnode.shapeFlag & 4 } let Mr = !1; function yf(e, t = !1) { t && ys(t); const { props: n, children: r } = e.vnode, s = na(e); Zc(e, n, s, t), Qc(e, r); const o = s ? pf(e, t) : void 0; return t && ys(!1), o } function pf(e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, jc); const { setup: r } = n; if (r) { const s = e.setupContext = r.length > 1 ? _f(e) : null, o = Mn(e); wt(); const i = pt(r, e, 0, [e.props, s]); if (Ct(), o(), Ji(i)) { if (i.then(zo, zo), t) return i.then(l => { Uo(e, l, t) }).catch(l => { Or(l, e, 0) }); e.asyncDep = i } else Uo(e, i, t) } else ra(e, t) } function Uo(e, t, n) { q(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : ie(t) && (e.setupState = Cl(t)), ra(e, n) } let Ko; function ra(e, t, n) { const r = e.type; if (!e.render) { if (!t && Ko && !r.render) { const s = r.template || Xs(e).template; if (s) { const { isCustomElement: o, compilerOptions: i } = e.appContext.config, { delimiters: l, compilerOptions: a } = r, u = be(be({ isCustomElement: o, delimiters: l }, i), a); r.render = Ko(s, u) } } e.render = r.render || Be } { const s = Mn(e); wt(); try { Wc(e) } finally { Ct(), s() } } } const bf = { get(e, t) { return Me(e, "get", ""), e[t] } }; function _f(e) { const t = n => { e.exposed = n || {} }; return { attrs: new Proxy(e.attrs, bf), slots: e.slots, emit: e.emit, expose: t } } function Fr(e) { if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(Cl(lc(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in gn) return gn[n](e) }, has(t, n) { return n in t || n in gn } })) } function wf(e, t = !0) { return q(e) ? e.displayName || e.name : e.name || t && e.__name } function Cf(e) { return q(e) && "__vccOpts" in e } const E = (e, t) => ac(e, t, Mr); function en(e, t, n) { const r = arguments.length; return r === 2 ? ie(t) && !K(t) ? vs(t) ? p(e, null, [t]) : p(e, t) : p(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && vs(n) && (n = [n]), p(e, t, n)) } const Sf = "3.4.25";/**
* @vue/runtime-dom v3.4.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const xf = "http://www.w3.org/2000/svg", Ef = "http://www.w3.org/1998/Math/MathML", gt = typeof document < "u" ? document : null, Yo = gt && gt.createElement("template"), Tf = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, r) => { const s = t === "svg" ? gt.createElementNS(xf, e) : t === "mathml" ? gt.createElementNS(Ef, e) : gt.createElement(e, n ? { is: n } : void 0); return e === "select" && r && r.multiple != null && s.setAttribute("multiple", r.multiple), s }, createText: e => gt.createTextNode(e), createComment: e => gt.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => gt.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, r, s, o) { const i = n ? n.previousSibling : t.lastChild; if (s && (s === o || s.nextSibling)) for (; t.insertBefore(s.cloneNode(!0), n), !(s === o || !(s = s.nextSibling));); else { Yo.innerHTML = r === "svg" ? `<svg>${e}</svg>` : r === "mathml" ? `<math>${e}</math>` : e; const l = Yo.content; if (r === "svg" || r === "mathml") { const a = l.firstChild; for (; a.firstChild;)l.appendChild(a.firstChild); l.removeChild(a) } t.insertBefore(l, n) } return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }, ut = "transition", rn = "animation", Xt = Symbol("_vtc"), Fn = (e, { slots: t }) => en(Mc, oa(e), t); Fn.displayName = "Transition"; const sa = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, Af = Fn.props = be({}, Fl, sa), Tt = (e, t = []) => { K(e) ? e.forEach(n => n(...t)) : e && e(...t) }, Go = e => e ? K(e) ? e.some(t => t.length > 1) : e.length > 1 : !1; function oa(e) { const t = {}; for (const _ in e) _ in sa || (t[_] = e[_]); if (e.css === !1) return t; const { name: n = "v", type: r, duration: s, enterFromClass: o = `${n}-enter-from`, enterActiveClass: i = `${n}-enter-active`, enterToClass: l = `${n}-enter-to`, appearFromClass: a = o, appearActiveClass: u = i, appearToClass: c = l, leaveFromClass: f = `${n}-leave-from`, leaveActiveClass: m = `${n}-leave-active`, leaveToClass: h = `${n}-leave-to` } = e, b = Of(s), v = b && b[0], L = b && b[1], { onBeforeEnter: $, onEnter: D, onEnterCancelled: F, onLeave: W, onLeaveCancelled: U, onBeforeAppear: A = $, onAppear: S = D, onAppearCancelled: T = F } = t, V = (_, P, N) => { ct(_, P ? c : l), ct(_, P ? u : i), N && N() }, B = (_, P) => { _._isLeaving = !1, ct(_, f), ct(_, h), ct(_, m), P && P() }, H = _ => (P, N) => { const ye = _ ? S : D, ee = () => V(P, _, N); Tt(ye, [P, ee]), qo(() => { ct(P, _ ? a : o), tt(P, _ ? c : l), Go(ye) || Zo(P, r, v, ee) }) }; return be(t, { onBeforeEnter(_) { Tt($, [_]), tt(_, o), tt(_, i) }, onBeforeAppear(_) { Tt(A, [_]), tt(_, a), tt(_, u) }, onEnter: H(!1), onAppear: H(!0), onLeave(_, P) { _._isLeaving = !0; const N = () => B(_, P); tt(_, f), tt(_, m), la(), qo(() => { _._isLeaving && (ct(_, f), tt(_, h), Go(W) || Zo(_, r, L, N)) }), Tt(W, [_, N]) }, onEnterCancelled(_) { V(_, !1), Tt(F, [_]) }, onAppearCancelled(_) { V(_, !0), Tt(T, [_]) }, onLeaveCancelled(_) { B(_), Tt(U, [_]) } }) } function Of(e) { if (e == null) return null; if (ie(e)) return [Zr(e.enter), Zr(e.leave)]; { const t = Zr(e); return [t, t] } } function Zr(e) { return Iu(e) } function tt(e, t) { t.split(/\s+/).forEach(n => n && e.classList.add(n)), (e[Xt] || (e[Xt] = new Set)).add(t) } function ct(e, t) { t.split(/\s+/).forEach(r => r && e.classList.remove(r)); const n = e[Xt]; n && (n.delete(t), n.size || (e[Xt] = void 0)) } function qo(e) { requestAnimationFrame(() => { requestAnimationFrame(e) }) } let kf = 0; function Zo(e, t, n, r) { const s = e._endId = ++kf, o = () => { s === e._endId && r() }; if (n) return setTimeout(o, n); const { type: i, timeout: l, propCount: a } = ia(e, t); if (!i) return r(); const u = i + "end"; let c = 0; const f = () => { e.removeEventListener(u, m), o() }, m = h => { h.target === e && ++c >= a && f() }; setTimeout(() => { c < a && f() }, l + 1), e.addEventListener(u, m) } function ia(e, t) { const n = window.getComputedStyle(e), r = b => (n[b] || "").split(", "), s = r(`${ut}Delay`), o = r(`${ut}Duration`), i = Xo(s, o), l = r(`${rn}Delay`), a = r(`${rn}Duration`), u = Xo(l, a); let c = null, f = 0, m = 0; t === ut ? i > 0 && (c = ut, f = i, m = o.length) : t === rn ? u > 0 && (c = rn, f = u, m = a.length) : (f = Math.max(i, u), c = f > 0 ? i > u ? ut : rn : null, m = c ? c === ut ? o.length : a.length : 0); const h = c === ut && /\b(transform|all)(,|$)/.test(r(`${ut}Property`).toString()); return { type: c, timeout: f, propCount: m, hasTransform: h } } function Xo(e, t) { for (; e.length < t.length;)e = e.concat(e); return Math.max(...t.map((n, r) => Jo(n) + Jo(e[r]))) } function Jo(e) { return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3 } function la() { return document.body.offsetHeight } function Pf(e, t, n) { const r = e[Xt]; r && (t = (t ? [t, ...r] : [...r]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } const fr = Symbol("_vod"), aa = Symbol("_vsh"), ua = { beforeMount(e, { value: t }, { transition: n }) { e[fr] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : sn(e, t) }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e) }, updated(e, { value: t, oldValue: n }, { transition: r }) { !t != !n && (r ? t ? (r.beforeEnter(e), sn(e, !0), r.enter(e)) : r.leave(e, () => { sn(e, !1) }) : sn(e, t)) }, beforeUnmount(e, { value: t }) { sn(e, t) } }; function sn(e, t) { e.style.display = t ? e[fr] : "none", e[aa] = !t } const If = Symbol(""), Lf = /(^|;)\s*display\s*:/; function Mf(e, t, n) { const r = e.style, s = he(n); let o = !1; if (n && !s) { if (t) if (he(t)) for (const i of t.split(";")) { const l = i.slice(0, i.indexOf(":")).trim(); n[l] == null && Qn(r, l, "") } else for (const i in t) n[i] == null && Qn(r, i, ""); for (const i in n) i === "display" && (o = !0), Qn(r, i, n[i]) } else if (s) { if (t !== n) { const i = r[If]; i && (n += ";" + i), r.cssText = n, o = Lf.test(n) } } else t && e.removeAttribute("style"); fr in e && (e[fr] = o ? r.display : "", e[aa] && (r.display = "none")) } const Qo = /\s*!important$/; function Qn(e, t, n) { if (K(n)) n.forEach(r => Qn(e, t, r)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { const r = Ff(e, t); Qo.test(n) ? e.setProperty(Qt(r), n.replace(Qo, ""), "important") : e[r] = n } } const ei = ["Webkit", "Moz", "ms"], Xr = {}; function Ff(e, t) { const n = Xr[t]; if (n) return n; let r = Ge(t); if (r !== "filter" && r in e) return Xr[t] = r; r = st(r); for (let s = 0; s < ei.length; s++) { const o = ei[s] + r; if (o in e) return Xr[t] = o } return t } const ti = "http://www.w3.org/1999/xlink"; function Df(e, t, n, r, s) { if (r && t.startsWith("xlink:")) n == null ? e.removeAttributeNS(ti, t.slice(6, t.length)) : e.setAttributeNS(ti, t, n); else { const o = $u(t); n == null || o && !rl(n) ? e.removeAttribute(t) : e.setAttribute(t, o ? "" : n) } } function Rf(e, t, n, r, s, o, i) { if (t === "innerHTML" || t === "textContent") { r && i(r, s, o), e[t] = n ?? ""; return } const l = e.tagName; if (t === "value" && l !== "PROGRESS" && !l.includes("-")) { const u = l === "OPTION" ? e.getAttribute("value") || "" : e.value, c = n ?? ""; (u !== c || !("_value" in e)) && (e.value = c), n == null && e.removeAttribute(t), e._value = n; return } let a = !1; if (n === "" || n == null) { const u = typeof e[t]; u === "boolean" ? n = rl(n) : n == null && u === "string" ? (n = "", a = !0) : u === "number" && (n = 0, a = !0) } try { e[t] = n } catch { } a && e.removeAttribute(t) } function $f(e, t, n, r) { e.addEventListener(t, n, r) } function Nf(e, t, n, r) { e.removeEventListener(t, n, r) } const ni = Symbol("_vei"); function Vf(e, t, n, r, s = null) { const o = e[ni] || (e[ni] = {}), i = o[t]; if (r && i) i.value = r; else { const [l, a] = Bf(t); if (r) { const u = o[t] = Wf(r, s); $f(e, l, u, a) } else i && (Nf(e, l, i, a), o[t] = void 0) } } const ri = /(?:Once|Passive|Capture)$/; function Bf(e) { let t; if (ri.test(e)) { t = {}; let r; for (; r = e.match(ri);)e = e.slice(0, e.length - r[0].length), t[r[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : Qt(e.slice(2)), t] } let Jr = 0; const Hf = Promise.resolve(), jf = () => Jr || (Hf.then(() => Jr = 0), Jr = Date.now()); function Wf(e, t) { const n = r => { if (!r._vts) r._vts = Date.now(); else if (r._vts <= n.attached) return; He(zf(r, n.value), t, 5, [r]) }; return n.value = e, n.attached = jf(), n } function zf(e, t) { if (K(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(r => s => !s._stopped && r && r(s)) } else return t } const si = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, Uf = (e, t, n, r, s, o, i, l, a) => { const u = s === "svg"; t === "class" ? Pf(e, r, u) : t === "style" ? Mf(e, n, r) : xr(t) ? Ls(t) || Vf(e, t, n, r, i) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Kf(e, t, r, u)) ? Rf(e, t, r, o, i, l, a) : (t === "true-value" ? e._trueValue = r : t === "false-value" && (e._falseValue = r), Df(e, t, r, u)) }; function Kf(e, t, n, r) { if (r) return !!(t === "innerHTML" || t === "textContent" || t in e && si(t) && q(n)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const s = e.tagName; if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE") return !1 } return si(t) && he(n) ? !1 : t in e } const ca = new WeakMap, fa = new WeakMap, dr = Symbol("_moveCb"), oi = Symbol("_enterCb"), da = { name: "TransitionGroup", props: be({}, Af, { tag: String, moveClass: String }), setup(e, { slots: t }) { const n = no(), r = Ml(); let s, o; return Bl(() => { if (!s.length) return; const i = e.moveClass || `${e.name || "v"}-move`; if (!Jf(s[0].el, n.vnode.el, i)) return; s.forEach(qf), s.forEach(Zf); const l = s.filter(Xf); la(), l.forEach(a => { const u = a.el, c = u.style; tt(u, i), c.transform = c.webkitTransform = c.transitionDuration = ""; const f = u[dr] = m => { m && m.target !== u || (!m || /transform$/.test(m.propertyName)) && (u.removeEventListener("transitionend", f), u[dr] = null, ct(u, i)) }; u.addEventListener("transitionend", f) }) }), () => { const i = Q(e), l = oa(i); let a = i.tag || we; if (s = [], o) for (let u = 0; u < o.length; u++) { const c = o[u]; c.el && c.el instanceof Element && (s.push(c), Sn(c, Cn(c, l, r, n)), ca.set(c, c.el.getBoundingClientRect())) } o = t.default ? Zs(t.default()) : []; for (let u = 0; u < o.length; u++) { const c = o[u]; c.key != null && Sn(c, Cn(c, l, r, n)) } return p(a, null, o) } } }, Yf = e => delete e.mode; da.props; const Gf = da; function qf(e) { const t = e.el; t[dr] && t[dr](), t[oi] && t[oi]() } function Zf(e) { fa.set(e, e.el.getBoundingClientRect()) } function Xf(e) { const t = ca.get(e), n = fa.get(e), r = t.left - n.left, s = t.top - n.top; if (r || s) { const o = e.el.style; return o.transform = o.webkitTransform = `translate(${r}px,${s}px)`, o.transitionDuration = "0s", e } } function Jf(e, t, n) { const r = e.cloneNode(), s = e[Xt]; s && s.forEach(l => { l.split(/\s+/).forEach(a => a && r.classList.remove(a)) }), n.split(/\s+/).forEach(l => l && r.classList.add(l)), r.style.display = "none"; const o = t.nodeType === 1 ? t : t.parentNode; o.appendChild(r); const { hasTransform: i } = ia(r); return o.removeChild(r), i } const Qf = be({ patchProp: Uf }, Tf); let ii; function ed() { return ii || (ii = tf(Qf)) } const td = (...e) => { const t = ed().createApp(...e), { mount: n } = t; return t.mount = r => { const s = rd(r); if (!s) return; const o = t._component; !q(o) && !o.render && !o.template && (o.template = s.innerHTML), s.innerHTML = ""; const i = n(s, !1, nd(s)); return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), i }, t }; function nd(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function rd(e) { return he(e) ? document.querySelector(e) : e } function Dr(e, t) { let n; function r() { n = $s(), n.run(() => t.length ? t(() => { n == null || n.stop(), r() }) : t()) } oe(e, s => { s && !n ? r() : s || (n == null || n.stop(), n = void 0) }, { immediate: !0 }), qe(() => { n == null || n.stop() }) } const ge = typeof window < "u", ro = ge && "IntersectionObserver" in window, sd = ge && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0); function od(e, t, n) { const r = t.length - 1; if (r < 0) return e === void 0 ? n : e; for (let s = 0; s < r; s++) { if (e == null) return n; e = e[t[s]] } return e == null || e[t[r]] === void 0 ? n : e[t[r]] } function ma(e, t) { if (e === t) return !0; if (e instanceof Date && t instanceof Date && e.getTime() !== t.getTime() || e !== Object(e) || t !== Object(t)) return !1; const n = Object.keys(e); return n.length !== Object.keys(t).length ? !1 : n.every(r => ma(e[r], t[r])) } function li(e, t, n) { return e == null || !t || typeof t != "string" ? n : e[t] !== void 0 ? e[t] : (t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, ""), od(e, t.split("."), n)) } function ga(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0; return Array.from({ length: e }, (n, r) => t + r) } function J(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px"; if (!(e == null || e === "")) return isNaN(+e) ? String(e) : isFinite(+e) ? `${Number(e)}${t}` : void 0 } function ps(e) { return e !== null && typeof e == "object" && !Array.isArray(e) } function mr(e) { if (e && "$el" in e) { const t = e.$el; return (t == null ? void 0 : t.nodeType) === Node.TEXT_NODE ? t.nextElementSibling : t } return e } const ai = Object.freeze({ enter: 13, tab: 9, delete: 46, esc: 27, space: 32, up: 38, down: 40, left: 37, right: 39, end: 35, home: 36, del: 46, backspace: 8, insert: 45, pageup: 33, pagedown: 34, shift: 16 }); function Qr(e, t) { return t.every(n => e.hasOwnProperty(n)) } function id(e, t) { const n = {}, r = new Set(Object.keys(e)); for (const s of t) r.has(s) && (n[s] = e[s]); return n } const ld = /^on[^a-z]/, ha = e => ld.test(e); function bs(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1; return Math.max(t, Math.min(n, e)) } function ui(e, t) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0"; return e + n.repeat(Math.max(0, t - e.length)) } function ci(e, t) { return (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0").repeat(Math.max(0, t - e.length)) + e } function ad(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1; const n = []; let r = 0; for (; r < e.length;)n.push(e.substr(r, t)), r += t; return n } function $e() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0; const r = {}; for (const s in e) r[s] = e[s]; for (const s in t) { const o = e[s], i = t[s]; if (ps(o) && ps(i)) { r[s] = $e(o, i, n); continue } if (Array.isArray(o) && Array.isArray(i) && n) { r[s] = n(o, i); continue } r[s] = i } return r } function va(e) { return e.map(t => t.type === we ? va(t.children) : t).flat() } function Mt() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ""; if (Mt.cache.has(e)) return Mt.cache.get(e); const t = e.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase(); return Mt.cache.set(e, t), t } Mt.cache = new Map; function er(e, t) { if (!t || typeof t != "object") return []; if (Array.isArray(t)) return t.map(n => er(e, n)).flat(1); if (Array.isArray(t.children)) return t.children.map(n => er(e, n)).flat(1); if (t.component) { if (Object.getOwnPropertySymbols(t.component.provides).includes(e)) return [t.component]; if (t.component.subTree) return er(e, t.component.subTree).flat(1) } return [] } function so(e) { const t = Ie({}), n = E(e); return Vt(() => { for (const r in n.value) t[r] = n.value[r] }, { flush: "sync" }), Us(t) } function gr(e, t) { return e.includes(t) } function ya(e) { return e[2].toLowerCase() + e.slice(3) } function fi(e, t) { return t = "on" + st(t), !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`]) } function ud(e, t) { if (!(ge && typeof CSS < "u" && typeof CSS.supports < "u" && CSS.supports(`selector(${t})`))) return null; try { return !!e && e.matches(t) } catch { return null } } function cd(e, t) { if (!ge || e === 0) return t(), () => { }; const n = window.setTimeout(t, e); return () => window.clearTimeout(n) } const pa = ["top", "bottom"], fd = ["start", "end", "left", "right"]; function _s(e, t) { let [n, r] = e.split(" "); return r || (r = gr(pa, n) ? "start" : gr(fd, n) ? "top" : "center"), { side: di(n, t), align: di(r, t) } } function di(e, t) { return e === "start" ? t ? "right" : "left" : e === "end" ? t ? "left" : "right" : e } function es(e) { return { side: { center: "center", top: "bottom", bottom: "top", left: "right", right: "left" }[e.side], align: e.align } } function ts(e) { return { side: e.side, align: { center: "center", top: "bottom", bottom: "top", left: "right", right: "left" }[e.align] } } function mi(e) { return { side: e.align, align: e.side } } function gi(e) { return gr(pa, e.side) ? "y" : "x" } class Ft { constructor(t) { let { x: n, y: r, width: s, height: o } = t; this.x = n, this.y = r, this.width = s, this.height = o } get top() { return this.y } get bottom() { return this.y + this.height } get left() { return this.x } get right() { return this.x + this.width } } function hi(e, t) { return { x: { before: Math.max(0, t.left - e.left), after: Math.max(0, e.right - t.right) }, y: { before: Math.max(0, t.top - e.top), after: Math.max(0, e.bottom - t.bottom) } } } function dd(e) { return Array.isArray(e) ? new Ft({ x: e[0], y: e[1], width: 0, height: 0 }) : e.getBoundingClientRect() } function md(e) { const t = e.getBoundingClientRect(), n = getComputedStyle(e), r = n.transform; if (r) { let s, o, i, l, a; if (r.startsWith("matrix3d(")) s = r.slice(9, -1).split(/, /), o = +s[0], i = +s[5], l = +s[12], a = +s[13]; else if (r.startsWith("matrix(")) s = r.slice(7, -1).split(/, /), o = +s[0], i = +s[3], l = +s[4], a = +s[5]; else return new Ft(t); const u = n.transformOrigin, c = t.x - l - (1 - o) * parseFloat(u), f = t.y - a - (1 - i) * parseFloat(u.slice(u.indexOf(" ") + 1)), m = o ? t.width / o : e.offsetWidth + 1, h = i ? t.height / i : e.offsetHeight + 1; return new Ft({ x: c, y: f, width: m, height: h }) } else return new Ft(t) } function gd(e, t, n) { if (typeof e.animate > "u") return { finished: Promise.resolve() }; let r; try { r = e.animate(t, n) } catch { return { finished: Promise.resolve() } } return typeof r.finished > "u" && (r.finished = new Promise(s => { r.onfinish = () => { s(r) } })), r } const tr = new WeakMap; function hd(e, t) { Object.keys(t).forEach(n => { if (ha(n)) { const r = ya(n), s = tr.get(e); if (t[n] == null) s == null || s.forEach(o => { const [i, l] = o; i === r && (e.removeEventListener(r, l), s.delete(o)) }); else if (!s || ![...s].some(o => o[0] === r && o[1] === t[n])) { e.addEventListener(r, t[n]); const o = s || new Set; o.add([r, t[n]]), tr.has(e) || tr.set(e, o) } } else t[n] == null ? e.removeAttribute(n) : e.setAttribute(n, t[n]) }) } function vd(e, t) { Object.keys(t).forEach(n => { if (ha(n)) { const r = ya(n), s = tr.get(e); s == null || s.forEach(o => { const [i, l] = o; i === r && (e.removeEventListener(r, l), s.delete(o)) }) } else e.removeAttribute(n) }) } const Kt = 2.4, vi = .2126729, yi = .7151522, pi = .072175, yd = .55, pd = .58, bd = .57, _d = .62, Yn = .03, bi = 1.45, wd = 5e-4, Cd = 1.25, Sd = 1.25, _i = .078, wi = 12.82051282051282, Gn = .06, Ci = .001; function Si(e, t) { const n = (e.r / 255) ** Kt, r = (e.g / 255) ** Kt, s = (e.b / 255) ** Kt, o = (t.r / 255) ** Kt, i = (t.g / 255) ** Kt, l = (t.b / 255) ** Kt; let a = n * vi + r * yi + s * pi, u = o * vi + i * yi + l * pi; if (a <= Yn && (a += (Yn - a) ** bi), u <= Yn && (u += (Yn - u) ** bi), Math.abs(u - a) < wd) return 0; let c; if (u > a) { const f = (u ** yd - a ** pd) * Cd; c = f < Ci ? 0 : f < _i ? f - f * wi * Gn : f - Gn } else { const f = (u ** _d - a ** bd) * Sd; c = f > -Ci ? 0 : f > -_i ? f - f * wi * Gn : f + Gn } return c * 100 } const hr = .20689655172413793, xd = e => e > hr ** 3 ? Math.cbrt(e) : e / (3 * hr ** 2) + 4 / 29, Ed = e => e > hr ? e ** 3 : 3 * hr ** 2 * (e - 4 / 29); function ba(e) { const t = xd, n = t(e[1]); return [116 * n - 16, 500 * (t(e[0] / .95047) - n), 200 * (n - t(e[2] / 1.08883))] } function _a(e) { const t = Ed, n = (e[0] + 16) / 116; return [t(n + e[1] / 500) * .95047, t(n), t(n - e[2] / 200) * 1.08883] } const Td = [[3.2406, -1.5372, -.4986], [-.9689, 1.8758, .0415], [.0557, -.204, 1.057]], Ad = e => e <= .0031308 ? e * 12.92 : 1.055 * e ** (1 / 2.4) - .055, Od = [[.4124, .3576, .1805], [.2126, .7152, .0722], [.0193, .1192, .9505]], kd = e => e <= .04045 ? e / 12.92 : ((e + .055) / 1.055) ** 2.4; function wa(e) { const t = Array(3), n = Ad, r = Td; for (let s = 0; s < 3; ++s)t[s] = Math.round(bs(n(r[s][0] * e[0] + r[s][1] * e[1] + r[s][2] * e[2])) * 255); return { r: t[0], g: t[1], b: t[2] } } function oo(e) { let { r: t, g: n, b: r } = e; const s = [0, 0, 0], o = kd, i = Od; t = o(t / 255), n = o(n / 255), r = o(r / 255); for (let l = 0; l < 3; ++l)s[l] = i[l][0] * t + i[l][1] * n + i[l][2] * r; return s } function ws(e) { return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e) } function Pd(e) { return ws(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e) } const xi = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/, Id = { rgb: (e, t, n, r) => ({ r: e, g: t, b: n, a: r }), rgba: (e, t, n, r) => ({ r: e, g: t, b: n, a: r }), hsl: (e, t, n, r) => Ei({ h: e, s: t, l: n, a: r }), hsla: (e, t, n, r) => Ei({ h: e, s: t, l: n, a: r }), hsv: (e, t, n, r) => En({ h: e, s: t, v: n, a: r }), hsva: (e, t, n, r) => En({ h: e, s: t, v: n, a: r }) }; function et(e) {
    if (typeof e == "number") return { r: (e & 16711680) >> 16, g: (e & 65280) >> 8, b: e & 255 }; if (typeof e == "string" && xi.test(e)) { const { groups: t } = e.match(xi), { fn: n, values: r } = t, s = r.split(/,\s*/).map(o => o.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(n) ? parseFloat(o) / 100 : parseFloat(o)); return Id[n](...s) } else if (typeof e == "string") { let t = e.startsWith("#") ? e.slice(1) : e; return [3, 4].includes(t.length) ? t = t.split("").map(n => n + n).join("") : [6, 8].includes(t.length), Md(t) } else if (typeof e == "object") { if (Qr(e, ["r", "g", "b"])) return e; if (Qr(e, ["h", "s", "l"])) return En(Ca(e)); if (Qr(e, ["h", "s", "v"])) return En(e) } throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`)
} function En(e) { const { h: t, s: n, v: r, a: s } = e, o = l => { const a = (l + t / 60) % 6; return r - r * n * Math.max(Math.min(a, 4 - a, 1), 0) }, i = [o(5), o(3), o(1)].map(l => Math.round(l * 255)); return { r: i[0], g: i[1], b: i[2], a: s } } function Ei(e) { return En(Ca(e)) } function Ca(e) { const { h: t, s: n, l: r, a: s } = e, o = r + n * Math.min(r, 1 - r), i = o === 0 ? 0 : 2 - 2 * r / o; return { h: t, s: i, v: o, a: s } } function qn(e) { const t = Math.round(e).toString(16); return ("00".substr(0, 2 - t.length) + t).toUpperCase() } function Ld(e) { let { r: t, g: n, b: r, a: s } = e; return `#${[qn(t), qn(n), qn(r), s !== void 0 ? qn(Math.round(s * 255)) : ""].join("")}` } function Md(e) { e = Fd(e); let [t, n, r, s] = ad(e, 2).map(o => parseInt(o, 16)); return s = s === void 0 ? s : s / 255, { r: t, g: n, b: r, a: s } } function Fd(e) { return e.startsWith("#") && (e = e.slice(1)), e = e.replace(/([^0-9a-f])/gi, "F"), (e.length === 3 || e.length === 4) && (e = e.split("").map(t => t + t).join("")), e.length !== 6 && (e = ui(ui(e, 6), 8, "F")), e } function Dd(e, t) { const n = ba(oo(e)); return n[0] = n[0] + t * 10, wa(_a(n)) } function Rd(e, t) { const n = ba(oo(e)); return n[0] = n[0] - t * 10, wa(_a(n)) } function $d(e) { const t = et(e); return oo(t)[1] } function Sa(e) { const t = Math.abs(Si(et(0), et(e))); return Math.abs(Si(et(16777215), et(e))) > Math.min(t, 50) ? "#fff" : "#000" } function Z(e, t) { return n => Object.keys(e).reduce((r, s) => { const i = typeof e[s] == "object" && e[s] != null && !Array.isArray(e[s]) ? e[s] : { type: e[s] }; return n && s in n ? r[s] = { ...i, default: n[s] } : r[s] = i, t && !r[s].source && (r[s].source = t), r }, {}) } const Te = Z({ class: [String, Array], style: { type: [String, Array, Object], default: null } }, "component"), Jt = Symbol.for("vuetify:defaults"); function Nd(e) { return ce(e) } function io() { const e = Le(Jt); if (!e) throw new Error("[Vuetify] Could not find defaults instance"); return e } function xa(e, t) { const n = io(), r = ce(e), s = E(() => { if (vt(t == null ? void 0 : t.disabled)) return n.value; const i = vt(t == null ? void 0 : t.scoped), l = vt(t == null ? void 0 : t.reset), a = vt(t == null ? void 0 : t.root); if (r.value == null && !(i || l || a)) return n.value; let u = $e(r.value, { prev: n.value }); if (i) return u; if (l || a) { const c = Number(l || 1 / 0); for (let f = 0; f <= c && !(!u || !("prev" in u)); f++)u = u.prev; return u && typeof a == "string" && a in u && (u = $e($e(u, { prev: u }), u[a])), u } return u.prev ? $e(u.prev, u) : u }); return Ht(Jt, s), s } function Vd(e, t) { var n, r; return typeof ((n = e.props) == null ? void 0 : n[t]) < "u" || typeof ((r = e.props) == null ? void 0 : r[Mt(t)]) < "u" } function Bd() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : io(); const r = ke("useDefaults"); if (t = t ?? r.type.name ?? r.type.__name, !t) throw new Error("[Vuetify] Could not determine component name"); const s = E(() => { var a; return (a = n.value) == null ? void 0 : a[e._as ?? t] }), o = new Proxy(e, { get(a, u) { var f, m, h, b; const c = Reflect.get(a, u); return u === "class" || u === "style" ? [(f = s.value) == null ? void 0 : f[u], c].filter(v => v != null) : typeof u == "string" && !Vd(r.vnode, u) ? ((m = s.value) == null ? void 0 : m[u]) ?? ((b = (h = n.value) == null ? void 0 : h.global) == null ? void 0 : b[u]) ?? c : c } }), i = me(); Vt(() => { if (s.value) { const a = Object.entries(s.value).filter(u => { let [c] = u; return c.startsWith(c[0].toUpperCase()) }); i.value = a.length ? Object.fromEntries(a) : void 0 } else i.value = void 0 }); function l() { const a = zd(Jt, r); Ht(Jt, E(() => i.value ? $e((a == null ? void 0 : a.value) ?? {}, i.value) : a == null ? void 0 : a.value)) } return { props: o, provideSubDefaults: l } } function Dn(e) { if (e._setup = e._setup ?? e.setup, !e.name) return e; if (e._setup) { e.props = Z(e.props ?? {}, e.name)(); const t = Object.keys(e.props).filter(n => n !== "class" && n !== "style"); e.filterProps = function (r) { return id(r, t) }, e.props._as = String, e.setup = function (r, s) { const o = io(); if (!o.value) return e._setup(r, s); const { props: i, provideSubDefaults: l } = Bd(r, r._as ?? e.name, o), a = e._setup(i, s); return l(), a } } return e } function Ce() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0; return t => (e ? Dn : Fc)(t) } function Rr(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div", n = arguments.length > 2 ? arguments[2] : void 0; return Ce()({ name: n ?? st(Ge(e.replace(/__/g, "-"))), props: { tag: { type: String, default: t }, ...Te() }, setup(r, s) { let { slots: o } = s; return () => { var i; return en(r.tag, { class: [e, r.class], style: r.style }, (i = o.default) == null ? void 0 : i.call(o)) } } }) } function Ea(e) { if (typeof e.getRootNode != "function") { for (; e.parentNode;)e = e.parentNode; return e !== document ? null : document } const t = e.getRootNode(); return t !== document && t.getRootNode({ composed: !0 }) !== document ? null : t } const Hd = "cubic-bezier(0.4, 0, 0.2, 1)"; function ke(e, t) { const n = no(); if (!n) throw new Error(`[Vuetify] ${e} ${t || "must be called from inside a setup function"}`); return n } function St() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables"; const t = ke(e).type; return Mt((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name)) } let Ta = 0, nr = new WeakMap; function lo() { const e = ke("getUid"); if (nr.has(e)) return nr.get(e); { const t = Ta++; return nr.set(e, t), t } } lo.reset = () => { Ta = 0, nr = new WeakMap }; function jd(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1; for (; e;) { if (t ? Wd(e) : ao(e)) return e; e = e.parentElement } return document.scrollingElement } function vr(e, t) { const n = []; if (t && e && !t.contains(e)) return n; for (; e && (ao(e) && n.push(e), e !== t);)e = e.parentElement; return n } function ao(e) { if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1; const t = window.getComputedStyle(e); return t.overflowY === "scroll" || t.overflowY === "auto" && e.scrollHeight > e.clientHeight } function Wd(e) { if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1; const t = window.getComputedStyle(e); return ["scroll", "auto"].includes(t.overflowY) } function zd(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke("injectSelf"); const { provides: n } = t; if (n && e in n) return n[e] } function Ud(e) { for (; e;) { if (window.getComputedStyle(e).position === "fixed") return !0; e = e.offsetParent } return !1 } function Ne(e) { const t = ke("useRender"); t.render = e } function uo(e, t, n) { let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : f => f, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : f => f; const o = ke("useProxiedModel"), i = ce(e[t] !== void 0 ? e[t] : n), l = Mt(t), u = E(l !== t ? () => { var f, m, h, b; return e[t], !!(((f = o.vnode.props) != null && f.hasOwnProperty(t) || (m = o.vnode.props) != null && m.hasOwnProperty(l)) && ((h = o.vnode.props) != null && h.hasOwnProperty(`onUpdate:${t}`) || (b = o.vnode.props) != null && b.hasOwnProperty(`onUpdate:${l}`))) } : () => { var f, m; return e[t], !!((f = o.vnode.props) != null && f.hasOwnProperty(t) && ((m = o.vnode.props) != null && m.hasOwnProperty(`onUpdate:${t}`))) }); Dr(() => !u.value, () => { oe(() => e[t], f => { i.value = f }) }); const c = E({ get() { const f = e[t]; return r(u.value ? f : i.value) }, set(f) { const m = s(f), h = Q(u.value ? e[t] : i.value); h === m || r(h) === f || (i.value = m, o == null || o.emit(`update:${t}`, m)) } }); return Object.defineProperty(c, "externalValue", { get: () => u.value ? e[t] : i.value }), c } const Kd = { badge: "Badge", open: "Open", close: "Close", dismiss: "Dismiss", confirmEdit: { ok: "OK", cancel: "Cancel" }, dataIterator: { noResultsText: "No matching records found", loadingText: "Loading items..." }, dataTable: { itemsPerPageText: "Rows per page:", ariaLabel: { sortDescending: "Sorted descending.", sortAscending: "Sorted ascending.", sortNone: "Not sorted.", activateNone: "Activate to remove sorting.", activateDescending: "Activate to sort descending.", activateAscending: "Activate to sort ascending." }, sortBy: "Sort by" }, dataFooter: { itemsPerPageText: "Items per page:", itemsPerPageAll: "All", nextPage: "Next page", prevPage: "Previous page", firstPage: "First page", lastPage: "Last page", pageText: "{0}-{1} of {2}" }, dateRangeInput: { divider: "to" }, datePicker: { itemsSelected: "{0} selected", range: { title: "Select dates", header: "Enter dates" }, title: "Select date", header: "Enter date", input: { placeholder: "Enter date" } }, noDataText: "No data available", carousel: { prev: "Previous visual", next: "Next visual", ariaLabel: { delimiter: "Carousel slide {0} of {1}" } }, calendar: { moreEvents: "{0} more", today: "Today" }, input: { clear: "Clear {0}", prependAction: "{0} prepended action", appendAction: "{0} appended action", otp: "Please enter OTP character {0}" }, fileInput: { counter: "{0} files", counterSize: "{0} files ({1} in total)" }, timePicker: { am: "AM", pm: "PM", title: "Select Time" }, pagination: { ariaLabel: { root: "Pagination Navigation", next: "Next page", previous: "Previous page", page: "Go to page {0}", currentPage: "Page {0}, Current page", first: "First page", last: "Last page" } }, stepper: { next: "Next", prev: "Previous" }, rating: { ariaLabel: { item: "Rating {0} of {1}" } }, loading: "Loading...", infiniteScroll: { loadMore: "Load more", empty: "No more" } }, Ti = "$vuetify.", Ai = (e, t) => e.replace(/\{(\d+)\}/g, (n, r) => String(t[+r])), Aa = (e, t, n) => function (r) { for (var s = arguments.length, o = new Array(s > 1 ? s - 1 : 0), i = 1; i < s; i++)o[i - 1] = arguments[i]; if (!r.startsWith(Ti)) return Ai(r, o); const l = r.replace(Ti, ""), a = e.value && n.value[e.value], u = t.value && n.value[t.value]; let c = li(a, l, null); return c || (`${r}${e.value}`, c = li(u, l, null)), c || (c = r), typeof c != "string" && (c = r), Ai(c, o) }; function Oa(e, t) { return (n, r) => new Intl.NumberFormat([e.value, t.value], r).format(n) } function ns(e, t, n) { const r = uo(e, t, e[t] ?? n.value); return r.value = e[t] ?? n.value, oe(n, s => { e[t] == null && (r.value = n.value) }), r } function ka(e) { return t => { const n = ns(t, "locale", e.current), r = ns(t, "fallback", e.fallback), s = ns(t, "messages", e.messages); return { name: "vuetify", current: n, fallback: r, messages: s, t: Aa(n, r, s), n: Oa(n, r), provide: ka({ current: n, fallback: r, messages: s }) } } } function Yd(e) { const t = me((e == null ? void 0 : e.locale) ?? "en"), n = me((e == null ? void 0 : e.fallback) ?? "en"), r = ce({ en: Kd, ...e == null ? void 0 : e.messages }); return { name: "vuetify", current: t, fallback: n, messages: r, t: Aa(t, n, r), n: Oa(t, n), provide: ka({ current: t, fallback: n, messages: r }) } } const Cs = Symbol.for("vuetify:locale"); function Gd(e) { return e.name != null } function qd(e) { const t = e != null && e.adapter && Gd(e == null ? void 0 : e.adapter) ? e == null ? void 0 : e.adapter : Yd(e), n = Xd(t, e); return { ...t, ...n } } function Zd() { return { af: !1, ar: !0, bg: !1, ca: !1, ckb: !1, cs: !1, de: !1, el: !1, en: !1, es: !1, et: !1, fa: !0, fi: !1, fr: !1, hr: !1, hu: !1, he: !0, id: !1, it: !1, ja: !1, km: !1, ko: !1, lv: !1, lt: !1, nl: !1, no: !1, pl: !1, pt: !1, ro: !1, ru: !1, sk: !1, sl: !1, srCyrl: !1, srLatn: !1, sv: !1, th: !1, tr: !1, az: !1, uk: !1, vi: !1, zhHans: !1, zhHant: !1 } } function Xd(e, t) { const n = ce((t == null ? void 0 : t.rtl) ?? Zd()), r = E(() => n.value[e.current.value] ?? !1); return { isRtl: r, rtl: n, rtlClasses: E(() => `v-locale--is-${r.value ? "rtl" : "ltr"}`) } } function Rn() { const e = Le(Cs); if (!e) throw new Error("[Vuetify] Could not find injected rtl instance"); return { isRtl: e.isRtl, rtlClasses: e.rtlClasses } } const Tn = { "001": 1, AD: 1, AE: 6, AF: 6, AG: 0, AI: 1, AL: 1, AM: 1, AN: 1, AR: 1, AS: 0, AT: 1, AU: 1, AX: 1, AZ: 1, BA: 1, BD: 0, BE: 1, BG: 1, BH: 6, BM: 1, BN: 1, BR: 0, BS: 0, BT: 0, BW: 0, BY: 1, BZ: 0, CA: 0, CH: 1, CL: 1, CM: 1, CN: 1, CO: 0, CR: 1, CY: 1, CZ: 1, DE: 1, DJ: 6, DK: 1, DM: 0, DO: 0, DZ: 6, EC: 1, EE: 1, EG: 6, ES: 1, ET: 0, FI: 1, FJ: 1, FO: 1, FR: 1, GB: 1, "GB-alt-variant": 0, GE: 1, GF: 1, GP: 1, GR: 1, GT: 0, GU: 0, HK: 0, HN: 0, HR: 1, HU: 1, ID: 0, IE: 1, IL: 0, IN: 0, IQ: 6, IR: 6, IS: 1, IT: 1, JM: 0, JO: 6, JP: 0, KE: 0, KG: 1, KH: 0, KR: 0, KW: 6, KZ: 1, LA: 0, LB: 1, LI: 1, LK: 1, LT: 1, LU: 1, LV: 1, LY: 6, MC: 1, MD: 1, ME: 1, MH: 0, MK: 1, MM: 0, MN: 1, MO: 0, MQ: 1, MT: 0, MV: 5, MX: 0, MY: 1, MZ: 0, NI: 0, NL: 1, NO: 1, NP: 0, NZ: 1, OM: 6, PA: 0, PE: 0, PH: 0, PK: 0, PL: 1, PR: 0, PT: 0, PY: 0, QA: 6, RE: 1, RO: 1, RS: 1, RU: 1, SA: 0, SD: 6, SE: 1, SG: 0, SI: 1, SK: 1, SM: 1, SV: 0, SY: 6, TH: 0, TJ: 1, TM: 1, TR: 1, TT: 0, TW: 0, UA: 1, UM: 0, US: 0, UY: 1, UZ: 1, VA: 1, VE: 0, VI: 0, VN: 1, WS: 0, XK: 1, YE: 0, ZA: 0, ZW: 0 }; function Jd(e, t) { const n = []; let r = []; const s = Pa(e), o = Ia(e), i = (s.getDay() - Tn[t.slice(-2).toUpperCase()] + 7) % 7, l = (o.getDay() - Tn[t.slice(-2).toUpperCase()] + 7) % 7; for (let a = 0; a < i; a++) { const u = new Date(s); u.setDate(u.getDate() - (i - a)), r.push(u) } for (let a = 1; a <= o.getDate(); a++) { const u = new Date(e.getFullYear(), e.getMonth(), a); r.push(u), r.length === 7 && (n.push(r), r = []) } for (let a = 1; a < 7 - l; a++) { const u = new Date(o); u.setDate(u.getDate() + a), r.push(u) } return r.length > 0 && n.push(r), n } function Qd(e, t) { const n = new Date(e); for (; n.getDay() !== (Tn[t.slice(-2).toUpperCase()] ?? 0);)n.setDate(n.getDate() - 1); return n } function em(e, t) { const n = new Date(e), r = ((Tn[t.slice(-2).toUpperCase()] ?? 0) + 6) % 7; for (; n.getDay() !== r;)n.setDate(n.getDate() + 1); return n } function Pa(e) { return new Date(e.getFullYear(), e.getMonth(), 1) } function Ia(e) { return new Date(e.getFullYear(), e.getMonth() + 1, 0) } function tm(e) { const t = e.split("-").map(Number); return new Date(t[0], t[1] - 1, t[2]) } const nm = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/; function La(e) { if (e == null) return new Date; if (e instanceof Date) return e; if (typeof e == "string") { let t; if (nm.test(e)) return tm(e); if (t = Date.parse(e), !isNaN(t)) return new Date(t) } return null } const Oi = new Date(2e3, 0, 2); function rm(e) { const t = Tn[e.slice(-2).toUpperCase()]; return ga(7).map(n => { const r = new Date(Oi); return r.setDate(Oi.getDate() + t + n), new Intl.DateTimeFormat(e, { weekday: "narrow" }).format(r) }) } function sm(e, t, n, r) { const s = La(e) ?? new Date, o = r == null ? void 0 : r[t]; if (typeof o == "function") return o(s, t, n); let i = {}; switch (t) { case "fullDateWithWeekday": i = { weekday: "long", day: "numeric", month: "long", year: "numeric" }; break; case "hours12h": i = { hour: "numeric", hour12: !0 }; break; case "normalDateWithWeekday": i = { weekday: "short", day: "numeric", month: "short" }; break; case "keyboardDate": i = { day: "2-digit", month: "2-digit", year: "numeric" }; break; case "monthAndDate": i = { month: "long", day: "numeric" }; break; case "monthAndYear": i = { month: "long", year: "numeric" }; break; case "month": i = { month: "long" }; break; case "monthShort": i = { month: "short" }; break; case "dayOfMonth": return new Intl.NumberFormat(n).format(s.getDate()); case "shortDate": i = { year: "2-digit", month: "numeric", day: "numeric" }; break; case "weekdayShort": i = { weekday: "short" }; break; case "year": i = { year: "numeric" }; break; default: i = o ?? { timeZone: "UTC", timeZoneName: "short" } }return new Intl.DateTimeFormat(n, i).format(s) } function om(e, t) { const n = e.toJsDate(t), r = n.getFullYear(), s = ci(String(n.getMonth() + 1), 2, "0"), o = ci(String(n.getDate()), 2, "0"); return `${r}-${s}-${o}` } function im(e) { const [t, n, r] = e.split("-").map(Number); return new Date(t, n - 1, r) } function lm(e, t) { const n = new Date(e); return n.setMinutes(n.getMinutes() + t), n } function am(e, t) { const n = new Date(e); return n.setHours(n.getHours() + t), n } function um(e, t) { const n = new Date(e); return n.setDate(n.getDate() + t), n } function cm(e, t) { const n = new Date(e); return n.setDate(n.getDate() + t * 7), n } function fm(e, t) { const n = new Date(e); return n.setMonth(n.getMonth() + t), n } function dm(e) { return e.getFullYear() } function mm(e) { return e.getMonth() } function gm(e) { return e.getDate() } function hm(e) { return new Date(e.getFullYear(), e.getMonth() + 1, 1) } function vm(e) { return e.getHours() } function ym(e) { return e.getMinutes() } function pm(e) { return new Date(e.getFullYear(), 0, 1) } function bm(e) { return new Date(e.getFullYear(), 11, 31) } function _m(e, t) { return Ss(e, t[0]) && Cm(e, t[1]) } function wm(e) { const t = new Date(e); return t instanceof Date && !isNaN(t.getTime()) } function Ss(e, t) { return e.getTime() > t.getTime() } function Cm(e, t) { return e.getTime() < t.getTime() } function ki(e, t) { return e.getTime() === t.getTime() } function Sm(e, t) { return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear() } function xm(e, t) { return e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear() } function Em(e, t, n) { const r = new Date(e), s = new Date(t); switch (n) { case "years": return r.getFullYear() - s.getFullYear(); case "quarters": return Math.floor((r.getMonth() - s.getMonth() + (r.getFullYear() - s.getFullYear()) * 12) / 4); case "months": return r.getMonth() - s.getMonth() + (r.getFullYear() - s.getFullYear()) * 12; case "weeks": return Math.floor((r.getTime() - s.getTime()) / (1e3 * 60 * 60 * 24 * 7)); case "days": return Math.floor((r.getTime() - s.getTime()) / (1e3 * 60 * 60 * 24)); case "hours": return Math.floor((r.getTime() - s.getTime()) / (1e3 * 60 * 60)); case "minutes": return Math.floor((r.getTime() - s.getTime()) / (1e3 * 60)); case "seconds": return Math.floor((r.getTime() - s.getTime()) / 1e3); default: return r.getTime() - s.getTime() } } function Tm(e, t) { const n = new Date(e); return n.setHours(t), n } function Am(e, t) { const n = new Date(e); return n.setMinutes(t), n } function Om(e, t) { const n = new Date(e); return n.setMonth(t), n } function km(e, t) { const n = new Date(e); return n.setDate(t), n } function Pm(e, t) { const n = new Date(e); return n.setFullYear(t), n } function Im(e) { return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 0, 0, 0, 0) } function Lm(e) { return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 23, 59, 59, 999) } class Mm { constructor(t) { this.locale = t.locale, this.formats = t.formats } date(t) { return La(t) } toJsDate(t) { return t } toISO(t) { return om(this, t) } parseISO(t) { return im(t) } addMinutes(t, n) { return lm(t, n) } addHours(t, n) { return am(t, n) } addDays(t, n) { return um(t, n) } addWeeks(t, n) { return cm(t, n) } addMonths(t, n) { return fm(t, n) } getWeekArray(t) { return Jd(t, this.locale) } startOfWeek(t) { return Qd(t, this.locale) } endOfWeek(t) { return em(t, this.locale) } startOfMonth(t) { return Pa(t) } endOfMonth(t) { return Ia(t) } format(t, n) { return sm(t, n, this.locale, this.formats) } isEqual(t, n) { return ki(t, n) } isValid(t) { return wm(t) } isWithinRange(t, n) { return _m(t, n) } isAfter(t, n) { return Ss(t, n) } isBefore(t, n) { return !Ss(t, n) && !ki(t, n) } isSameDay(t, n) { return Sm(t, n) } isSameMonth(t, n) { return xm(t, n) } setMinutes(t, n) { return Am(t, n) } setHours(t, n) { return Tm(t, n) } setMonth(t, n) { return Om(t, n) } setDate(t, n) { return km(t, n) } setYear(t, n) { return Pm(t, n) } getDiff(t, n, r) { return Em(t, n, r) } getWeekdays() { return rm(this.locale) } getYear(t) { return dm(t) } getMonth(t) { return mm(t) } getDate(t) { return gm(t) } getNextMonth(t) { return hm(t) } getHours(t) { return vm(t) } getMinutes(t) { return ym(t) } startOfDay(t) { return Im(t) } endOfDay(t) { return Lm(t) } startOfYear(t) { return pm(t) } endOfYear(t) { return bm(t) } } const Fm = Symbol.for("vuetify:date-options"), Pi = Symbol.for("vuetify:date-adapter"); function Dm(e, t) { const n = $e({ adapter: Mm, locale: { af: "af-ZA", bg: "bg-BG", ca: "ca-ES", ckb: "", cs: "cs-CZ", de: "de-DE", el: "el-GR", en: "en-US", et: "et-EE", fa: "fa-IR", fi: "fi-FI", hr: "hr-HR", hu: "hu-HU", he: "he-IL", id: "id-ID", it: "it-IT", ja: "ja-JP", ko: "ko-KR", lv: "lv-LV", lt: "lt-LT", nl: "nl-NL", no: "no-NO", pl: "pl-PL", pt: "pt-PT", ro: "ro-RO", ru: "ru-RU", sk: "sk-SK", sl: "sl-SI", srCyrl: "sr-SP", srLatn: "sr-SP", sv: "sv-SE", th: "th-TH", tr: "tr-TR", az: "az-AZ", uk: "uk-UA", vi: "vi-VN", zhHans: "zh-CN", zhHant: "zh-TW" } }, e); return { options: n, instance: Rm(n, t) } } function Rm(e, t) { const n = Ie(typeof e.adapter == "function" ? new e.adapter({ locale: e.locale[t.current.value] ?? t.current.value, formats: e.formats }) : e.adapter); return oe(t.current, r => { n.locale = e.locale[r] ?? r ?? n.locale }), n } const $r = ["sm", "md", "lg", "xl", "xxl"], xs = Symbol.for("vuetify:display"), Ii = { mobileBreakpoint: "lg", thresholds: { xs: 0, sm: 600, md: 960, lg: 1280, xl: 1920, xxl: 2560 } }, $m = function () { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Ii; return $e(Ii, e) }; function Li(e) { return ge && !e ? window.innerWidth : typeof e == "object" && e.clientWidth || 0 } function Mi(e) { return ge && !e ? window.innerHeight : typeof e == "object" && e.clientHeight || 0 } function Fi(e) { const t = ge && !e ? window.navigator.userAgent : "ssr"; function n(b) { return !!t.match(b) } const r = n(/android/i), s = n(/iphone|ipad|ipod/i), o = n(/cordova/i), i = n(/electron/i), l = n(/chrome/i), a = n(/edge/i), u = n(/firefox/i), c = n(/opera/i), f = n(/win/i), m = n(/mac/i), h = n(/linux/i); return { android: r, ios: s, cordova: o, electron: i, chrome: l, edge: a, firefox: u, opera: c, win: f, mac: m, linux: h, touch: sd, ssr: t === "ssr" } } function Nm(e, t) { const { thresholds: n, mobileBreakpoint: r } = $m(e), s = me(Mi(t)), o = me(Fi(t)), i = Ie({}), l = me(Li(t)); function a() { s.value = Mi(), l.value = Li() } function u() { a(), o.value = Fi() } return Vt(() => { const c = l.value < n.sm, f = l.value < n.md && !c, m = l.value < n.lg && !(f || c), h = l.value < n.xl && !(m || f || c), b = l.value < n.xxl && !(h || m || f || c), v = l.value >= n.xxl, L = c ? "xs" : f ? "sm" : m ? "md" : h ? "lg" : b ? "xl" : "xxl", $ = typeof r == "number" ? r : n[r], D = l.value < $; i.xs = c, i.sm = f, i.md = m, i.lg = h, i.xl = b, i.xxl = v, i.smAndUp = !c, i.mdAndUp = !(c || f), i.lgAndUp = !(c || f || m), i.xlAndUp = !(c || f || m || h), i.smAndDown = !(m || h || b || v), i.mdAndDown = !(h || b || v), i.lgAndDown = !(b || v), i.xlAndDown = !v, i.name = L, i.height = s.value, i.width = l.value, i.mobile = D, i.mobileBreakpoint = r, i.platform = o.value, i.thresholds = n }), ge && window.addEventListener("resize", a, { passive: !0 }), { ...Us(i), update: u, ssr: !!t } } function Vm() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : St(); const n = Le(xs); if (!n) throw new Error("Could not find Vuetify display injection"); const r = E(() => { if (!e.mobileBreakpoint) return n.mobile.value; const o = typeof e.mobileBreakpoint == "number" ? e.mobileBreakpoint : n.thresholds.value[e.mobileBreakpoint]; return n.width.value < o }), s = E(() => t ? { [`${t}--mobile`]: r.value } : {}); return { ...n, displayClasses: s, mobile: r } } const Bm = Symbol.for("vuetify:goto"); function Hm() { return { container: void 0, duration: 300, layout: !1, offset: 0, easing: "easeInOutCubic", patterns: { linear: e => e, easeInQuad: e => e ** 2, easeOutQuad: e => e * (2 - e), easeInOutQuad: e => e < .5 ? 2 * e ** 2 : -1 + (4 - 2 * e) * e, easeInCubic: e => e ** 3, easeOutCubic: e => --e ** 3 + 1, easeInOutCubic: e => e < .5 ? 4 * e ** 3 : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1, easeInQuart: e => e ** 4, easeOutQuart: e => 1 - --e ** 4, easeInOutQuart: e => e < .5 ? 8 * e ** 4 : 1 - 8 * --e ** 4, easeInQuint: e => e ** 5, easeOutQuint: e => 1 + --e ** 5, easeInOutQuint: e => e < .5 ? 16 * e ** 5 : 1 + 16 * --e ** 5 } } } function jm(e, t) { return { rtl: t.isRtl, options: $e(Hm(), e) } } const Wm = { collapse: "mdi-chevron-up", complete: "mdi-check", cancel: "mdi-close-circle", close: "mdi-close", delete: "mdi-close-circle", clear: "mdi-close-circle", success: "mdi-check-circle", info: "mdi-information", warning: "mdi-alert-circle", error: "mdi-close-circle", prev: "mdi-chevron-left", next: "mdi-chevron-right", checkboxOn: "mdi-checkbox-marked", checkboxOff: "mdi-checkbox-blank-outline", checkboxIndeterminate: "mdi-minus-box", delimiter: "mdi-circle", sortAsc: "mdi-arrow-up", sortDesc: "mdi-arrow-down", expand: "mdi-chevron-down", menu: "mdi-menu", subgroup: "mdi-menu-down", dropdown: "mdi-menu-down", radioOn: "mdi-radiobox-marked", radioOff: "mdi-radiobox-blank", edit: "mdi-pencil", ratingEmpty: "mdi-star-outline", ratingFull: "mdi-star", ratingHalf: "mdi-star-half-full", loading: "mdi-cached", first: "mdi-page-first", last: "mdi-page-last", unfold: "mdi-unfold-more-horizontal", file: "mdi-paperclip", plus: "mdi-plus", minus: "mdi-minus", calendar: "mdi-calendar", treeviewCollapse: "mdi-menu-down", treeviewExpand: "mdi-menu-right", eyeDropper: "mdi-eyedropper" }, zm = { component: e => en(Fa, { ...e, class: "mdi" }) }, Rt = [String, Function, Object, Array], Es = Symbol.for("vuetify:icons"), Nr = Z({ icon: { type: Rt }, tag: { type: String, required: !0 } }, "icon"), Di = Ce()({ name: "VComponentIcon", props: Nr(), setup(e, t) { let { slots: n } = t; return () => { const r = e.icon; return p(e.tag, null, { default: () => { var s; return [e.icon ? p(r, null, null) : (s = n.default) == null ? void 0 : s.call(n)] } }) } } }), Ma = Dn({ name: "VSvgIcon", inheritAttrs: !1, props: Nr(), setup(e, t) { let { attrs: n } = t; return () => p(e.tag, Ye(n, { style: null }), { default: () => [p("svg", { class: "v-icon__svg", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", role: "img", "aria-hidden": "true" }, [Array.isArray(e.icon) ? e.icon.map(r => Array.isArray(r) ? p("path", { d: r[0], "fill-opacity": r[1] }, null) : p("path", { d: r }, null)) : p("path", { d: e.icon }, null)])] }) } }); Dn({ name: "VLigatureIcon", props: Nr(), setup(e) { return () => p(e.tag, null, { default: () => [e.icon] }) } }); const Fa = Dn({ name: "VClassIcon", props: Nr(), setup(e) { return () => p(e.tag, { class: e.icon }, null) } }); function Um() { return { svg: { component: Ma }, class: { component: Fa } } } function Km(e) { const t = Um(), n = (e == null ? void 0 : e.defaultSet) ?? "mdi"; return n === "mdi" && !t.mdi && (t.mdi = zm), $e({ defaultSet: n, sets: t, aliases: { ...Wm, vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", .6]], "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z" } }, e) } const Ym = e => { const t = Le(Es); if (!t) throw new Error("Missing Vuetify Icons provide!"); return { iconData: E(() => { var a; const r = vt(e); if (!r) return { component: Di }; let s = r; if (typeof s == "string" && (s = s.trim(), s.startsWith("$") && (s = (a = t.aliases) == null ? void 0 : a[s.slice(1)])), Array.isArray(s)) return { component: Ma, icon: s }; if (typeof s != "string") return { component: Di, icon: s }; const o = Object.keys(t.sets).find(u => typeof s == "string" && s.startsWith(`${u}:`)), i = o ? s.slice(o.length + 1) : s; return { component: t.sets[o ?? t.defaultSet].component, icon: i } }) } }, yr = Symbol.for("vuetify:theme"), jt = Z({ theme: String }, "theme"); function Ri() { return { defaultTheme: "light", variations: { colors: [], lighten: 0, darken: 0 }, themes: { light: { dark: !1, colors: { background: "#FFFFFF", surface: "#FFFFFF", "surface-bright": "#FFFFFF", "surface-light": "#EEEEEE", "surface-variant": "#424242", "on-surface-variant": "#EEEEEE", primary: "#1867C0", "primary-darken-1": "#1F5592", secondary: "#48A9A6", "secondary-darken-1": "#018786", error: "#B00020", info: "#2196F3", success: "#4CAF50", warning: "#FB8C00" }, variables: { "border-color": "#000000", "border-opacity": .12, "high-emphasis-opacity": .87, "medium-emphasis-opacity": .6, "disabled-opacity": .38, "idle-opacity": .04, "hover-opacity": .04, "focus-opacity": .12, "selected-opacity": .08, "activated-opacity": .12, "pressed-opacity": .12, "dragged-opacity": .08, "theme-kbd": "#212529", "theme-on-kbd": "#FFFFFF", "theme-code": "#F5F5F5", "theme-on-code": "#000000" } }, dark: { dark: !0, colors: { background: "#121212", surface: "#212121", "surface-bright": "#ccbfd6", "surface-light": "#424242", "surface-variant": "#a3a3a3", "on-surface-variant": "#424242", primary: "#2196F3", "primary-darken-1": "#277CC1", secondary: "#54B6B2", "secondary-darken-1": "#48A9A6", error: "#CF6679", info: "#2196F3", success: "#4CAF50", warning: "#FB8C00" }, variables: { "border-color": "#FFFFFF", "border-opacity": .12, "high-emphasis-opacity": 1, "medium-emphasis-opacity": .7, "disabled-opacity": .5, "idle-opacity": .1, "hover-opacity": .04, "focus-opacity": .12, "selected-opacity": .08, "activated-opacity": .12, "pressed-opacity": .16, "dragged-opacity": .08, "theme-kbd": "#212529", "theme-on-kbd": "#FFFFFF", "theme-code": "#343434", "theme-on-code": "#CCCCCC" } } } } } function Gm() { var r, s; let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Ri(); const t = Ri(); if (!e) return { ...t, isDisabled: !0 }; const n = {}; for (const [o, i] of Object.entries(e.themes ?? {})) { const l = i.dark || o === "dark" ? (r = t.themes) == null ? void 0 : r.dark : (s = t.themes) == null ? void 0 : s.light; n[o] = $e(l, i) } return $e(t, { ...e, themes: n }) } function qm(e) { const t = Gm(e), n = ce(t.defaultTheme), r = ce(t.themes), s = E(() => { const c = {}; for (const [f, m] of Object.entries(r.value)) { const h = c[f] = { ...m, colors: { ...m.colors } }; if (t.variations) for (const b of t.variations.colors) { const v = h.colors[b]; if (v) for (const L of ["lighten", "darken"]) { const $ = L === "lighten" ? Dd : Rd; for (const D of ga(t.variations[L], 1)) h.colors[`${b}-${L}-${D}`] = Ld($(et(v), D)) } } for (const b of Object.keys(h.colors)) { if (/^on-[a-z]/.test(b) || h.colors[`on-${b}`]) continue; const v = `on-${b}`, L = et(h.colors[b]); h.colors[v] = Sa(L) } } return c }), o = E(() => s.value[n.value]), i = E(() => { var b; const c = []; (b = o.value) != null && b.dark && At(c, ":root", ["color-scheme: dark"]), At(c, ":root", $i(o.value)); for (const [v, L] of Object.entries(s.value)) At(c, `.v-theme--${v}`, [`color-scheme: ${L.dark ? "dark" : "normal"}`, ...$i(L)]); const f = [], m = [], h = new Set(Object.values(s.value).flatMap(v => Object.keys(v.colors))); for (const v of h) /^on-[a-z]/.test(v) ? At(m, `.${v}`, [`color: rgb(var(--v-theme-${v})) !important`]) : (At(f, `.bg-${v}`, [`--v-theme-overlay-multiplier: var(--v-theme-${v}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${v})) !important`, `color: rgb(var(--v-theme-on-${v})) !important`]), At(m, `.text-${v}`, [`color: rgb(var(--v-theme-${v})) !important`]), At(m, `.border-${v}`, [`--v-border-color: var(--v-theme-${v})`])); return c.push(...f, ...m), c.map((v, L) => L === 0 ? v : `    ${v}`).join("") }); function l() { return { style: [{ children: i.value, id: "vuetify-theme-stylesheet", nonce: t.cspNonce || !1 }] } } function a(c) { if (t.isDisabled) return; const f = c._context.provides.usehead; if (f) if (f.push) { const h = f.push(l); ge && oe(i, () => { h.patch(l) }) } else ge ? (f.addHeadObjs(E(l)), Vt(() => f.updateDOM())) : f.addHeadObjs(l()); else { let b = function () { if (typeof document < "u" && !h) { const v = document.createElement("style"); v.type = "text/css", v.id = "vuetify-theme-stylesheet", t.cspNonce && v.setAttribute("nonce", t.cspNonce), h = v, document.head.appendChild(h) } h && (h.innerHTML = i.value) }; var m = b; let h = ge ? document.getElementById("vuetify-theme-stylesheet") : null; ge ? oe(i, b, { immediate: !0 }) : b() } } const u = E(() => t.isDisabled ? void 0 : `v-theme--${n.value}`); return { install: a, isDisabled: t.isDisabled, name: n, themes: r, current: o, computedThemes: s, themeClasses: u, styles: i, global: { name: n, current: o } } } function Wt(e) { ke("provideTheme"); const t = Le(yr, null); if (!t) throw new Error("Could not find Vuetify theme injection"); const n = E(() => e.theme ?? t.name.value), r = E(() => t.themes.value[n.value]), s = E(() => t.isDisabled ? void 0 : `v-theme--${n.value}`), o = { ...t, name: n, current: r, themeClasses: s }; return Ht(yr, o), o } function At(e, t, n) {
    e.push(`${t} {
`, ...n.map(r => `  ${r};
`), `}
`)
} function $i(e) { const t = e.dark ? 2 : 1, n = e.dark ? 1 : 2, r = []; for (const [s, o] of Object.entries(e.colors)) { const i = et(o); r.push(`--v-theme-${s}: ${i.r},${i.g},${i.b}`), s.startsWith("on-") || r.push(`--v-theme-${s}-overlay-multiplier: ${$d(o) > .18 ? t : n}`) } for (const [s, o] of Object.entries(e.variables)) { const i = typeof o == "string" && o.startsWith("#") ? et(o) : void 0, l = i ? `${i.r}, ${i.g}, ${i.b}` : void 0; r.push(`--v-${s}: ${l ?? o}`) } return r } function Da(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content"; const n = ce(), r = ce(); if (ge) { const s = new ResizeObserver(o => { e == null || e(o, s), o.length && (t === "content" ? r.value = o[0].contentRect : r.value = o[0].target.getBoundingClientRect()) }); Bt(() => { s.disconnect() }), oe(n, (o, i) => { i && (s.unobserve(mr(i)), r.value = void 0), o && s.observe(mr(o)) }, { flush: "post" }) } return { resizeRef: n, contentRect: Pn(r) } } const pr = Symbol.for("vuetify:layout"), Ra = Symbol.for("vuetify:layout-item"), Ni = 1e3, Zm = Z({ overlaps: { type: Array, default: () => [] }, fullHeight: Boolean }, "layout"), Xm = Z({ name: { type: String }, order: { type: [Number, String], default: 0 }, absolute: Boolean }, "layout-item"); function Jm() { const e = Le(pr); if (!e) throw new Error("[Vuetify] Could not find injected layout"); return { getLayoutItem: e.getLayoutItem, mainRect: e.mainRect, mainStyles: e.mainStyles } } function Qm(e) { const t = Le(pr); if (!t) throw new Error("[Vuetify] Could not find injected layout"); const n = e.id ?? `layout-item-${lo()}`, r = ke("useLayoutItem"); Ht(Ra, { id: n }); const s = me(!1); $l(() => s.value = !0), Rl(() => s.value = !1); const { layoutItemStyles: o, layoutItemScrimStyles: i } = t.register(r, { ...e, active: E(() => s.value ? !1 : e.active.value), id: n }); return Bt(() => t.unregister(n)), { layoutItemStyles: o, layoutRect: t.layoutRect, layoutItemScrimStyles: i } } const eg = (e, t, n, r) => { let s = { top: 0, left: 0, right: 0, bottom: 0 }; const o = [{ id: "", layer: { ...s } }]; for (const i of e) { const l = t.get(i), a = n.get(i), u = r.get(i); if (!l || !a || !u) continue; const c = { ...s, [l.value]: parseInt(s[l.value], 10) + (u.value ? parseInt(a.value, 10) : 0) }; o.push({ id: i, layer: c }), s = c } return o }; function tg(e) { const t = Le(pr, null), n = E(() => t ? t.rootZIndex.value - 100 : Ni), r = ce([]), s = Ie(new Map), o = Ie(new Map), i = Ie(new Map), l = Ie(new Map), a = Ie(new Map), { resizeRef: u, contentRect: c } = Da(), f = E(() => { const A = new Map, S = e.overlaps ?? []; for (const T of S.filter(V => V.includes(":"))) { const [V, B] = T.split(":"); if (!r.value.includes(V) || !r.value.includes(B)) continue; const H = s.get(V), _ = s.get(B), P = o.get(V), N = o.get(B); !H || !_ || !P || !N || (A.set(B, { position: H.value, amount: parseInt(P.value, 10) }), A.set(V, { position: _.value, amount: -parseInt(N.value, 10) })) } return A }), m = E(() => { const A = [...new Set([...i.values()].map(T => T.value))].sort((T, V) => T - V), S = []; for (const T of A) { const V = r.value.filter(B => { var H; return ((H = i.get(B)) == null ? void 0 : H.value) === T }); S.push(...V) } return eg(S, s, o, l) }), h = E(() => !Array.from(a.values()).some(A => A.value)), b = E(() => m.value[m.value.length - 1].layer), v = E(() => ({ "--v-layout-left": J(b.value.left), "--v-layout-right": J(b.value.right), "--v-layout-top": J(b.value.top), "--v-layout-bottom": J(b.value.bottom), ...h.value ? void 0 : { transition: "none" } })), L = E(() => m.value.slice(1).map((A, S) => { let { id: T } = A; const { layer: V } = m.value[S], B = o.get(T), H = s.get(T); return { id: T, ...V, size: Number(B.value), position: H.value } })), $ = A => L.value.find(S => S.id === A), D = ke("createLayout"), F = me(!1); In(() => { F.value = !0 }), Ht(pr, { register: (A, S) => { let { id: T, order: V, position: B, layoutSize: H, elementSize: _, active: P, disableTransitions: N, absolute: ye } = S; i.set(T, V), s.set(T, B), o.set(T, H), l.set(T, P), N && a.set(T, N); const ne = er(Ra, D == null ? void 0 : D.vnode).indexOf(A); ne > -1 ? r.value.splice(ne, 0, T) : r.value.push(T); const Y = E(() => L.value.findIndex(pe => pe.id === T)), fe = E(() => n.value + m.value.length * 2 - Y.value * 2), We = E(() => { const pe = B.value === "left" || B.value === "right", lt = B.value === "right", tn = B.value === "bottom", le = { [B.value]: 0, zIndex: fe.value, transform: `translate${pe ? "X" : "Y"}(${(P.value ? 0 : -110) * (lt || tn ? -1 : 1)}%)`, position: ye.value || n.value !== Ni ? "absolute" : "fixed", ...h.value ? void 0 : { transition: "none" } }; if (!F.value) return le; const re = L.value[Y.value]; if (!re) throw new Error(`[Vuetify] Could not find layout item "${T}"`); const ze = f.value.get(T); return ze && (re[ze.position] += ze.amount), { ...le, height: pe ? `calc(100% - ${re.top}px - ${re.bottom}px)` : _.value ? `${_.value}px` : void 0, left: lt ? void 0 : `${re.left}px`, right: lt ? `${re.right}px` : void 0, top: B.value !== "bottom" ? `${re.top}px` : void 0, bottom: B.value !== "top" ? `${re.bottom}px` : void 0, width: pe ? _.value ? `${_.value}px` : void 0 : `calc(100% - ${re.left}px - ${re.right}px)` } }), Se = E(() => ({ zIndex: fe.value - 1 })); return { layoutItemStyles: We, layoutItemScrimStyles: Se, zIndex: fe } }, unregister: A => { i.delete(A), s.delete(A), o.delete(A), l.delete(A), a.delete(A), r.value = r.value.filter(S => S !== A) }, mainRect: b, mainStyles: v, getLayoutItem: $, items: L, layoutRect: c, rootZIndex: n }); const W = E(() => ["v-layout", { "v-layout--full-height": e.fullHeight }]), U = E(() => ({ zIndex: t ? n.value : void 0, position: t ? "relative" : void 0, overflow: t ? "hidden" : void 0 })); return { layoutClasses: W, layoutStyles: U, getLayoutItem: $, items: L, layoutRect: c, layoutRef: u } } function $a() { let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; const { blueprint: t, ...n } = e, r = $e(t, n), { aliases: s = {}, components: o = {}, directives: i = {} } = r, l = Nd(r.defaults), a = Nm(r.display, r.ssr), u = qm(r.theme), c = Km(r.icons), f = qd(r.locale), m = Dm(r.date, f), h = jm(r.goTo, f); return { install: v => { for (const L in i) v.directive(L, i[L]); for (const L in o) v.component(L, o[L]); for (const L in s) v.component(L, Dn({ ...s[L], name: L, aliasName: s[L].name })); if (u.install(v), v.provide(Jt, l), v.provide(xs, a), v.provide(yr, u), v.provide(Es, c), v.provide(Cs, f), v.provide(Fm, m.options), v.provide(Pi, m.instance), v.provide(Bm, h), ge && r.ssr) if (v.$nuxt) v.$nuxt.hook("app:suspense:resolve", () => { a.update() }); else { const { mount: L } = v; v.mount = function () { const $ = L(...arguments); return Nt(() => a.update()), v.mount = L, $ } } lo.reset(), v.mixin({ computed: { $vuetify() { return Ie({ defaults: Yt.call(this, Jt), display: Yt.call(this, xs), theme: Yt.call(this, yr), icons: Yt.call(this, Es), locale: Yt.call(this, Cs), date: Yt.call(this, Pi) }) } } }) }, defaults: l, display: a, theme: u, icons: c, locale: f, date: m, goTo: h } } const ng = "3.5.17"; $a.version = ng; function Yt(e) { var r, s; const t = this.$, n = ((r = t.parent) == null ? void 0 : r.provides) ?? ((s = t.vnode.appContext) == null ? void 0 : s.provides); if (n && e in n) return n[e] } const rg = $a({ theme: { defaultTheme: "dark" } }); function sg(e) { e.use(rg) } const og = (e, t) => { const n = e.__vccOpts || e; for (const [r, s] of t) n[r] = s; return n }, Na = Z({ border: [Boolean, Number, String] }, "border"); function Va(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : St(); return { borderClasses: E(() => { const r = ve(e) ? e.value : e.border, s = []; if (r === !0 || r === "") s.push(`${t}--border`); else if (typeof r == "string" || r === 0) for (const o of String(r).split(" ")) s.push(`border-${o}`); return s }) } } function co(e) { return so(() => { const t = [], n = {}; if (e.value.background) if (ws(e.value.background)) { if (n.backgroundColor = e.value.background, !e.value.text && Pd(e.value.background)) { const r = et(e.value.background); if (r.a == null || r.a === 1) { const s = Sa(r); n.color = s, n.caretColor = s } } } else t.push(`bg-${e.value.background}`); return e.value.text && (ws(e.value.text) ? (n.color = e.value.text, n.caretColor = e.value.text) : t.push(`text-${e.value.text}`)), { colorClasses: t, colorStyles: n } }) } function Ba(e, t) { const n = E(() => ({ text: ve(e) ? e.value : t ? e[t] : null })), { colorClasses: r, colorStyles: s } = co(n); return { textColorClasses: r, textColorStyles: s } } function An(e, t) { const n = E(() => ({ background: ve(e) ? e.value : t ? e[t] : null })), { colorClasses: r, colorStyles: s } = co(n); return { backgroundColorClasses: r, backgroundColorStyles: s } } const Ha = Z({ elevation: { type: [Number, String], validator(e) { const t = parseInt(e); return !isNaN(t) && t >= 0 && t <= 24 } } }, "elevation"); function ja(e) { return { elevationClasses: E(() => { const n = ve(e) ? e.value : e.elevation, r = []; return n == null || r.push(`elevation-${n}`), r }) } } const $n = Z({ rounded: { type: [Boolean, Number, String], default: void 0 }, tile: Boolean }, "rounded"); function Nn(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : St(); return { roundedClasses: E(() => { const r = ve(e) ? e.value : e.rounded, s = ve(e) ? e.value : e.tile, o = []; if (r === !0 || r === "") o.push(`${t}--rounded`); else if (typeof r == "string" || r === 0) for (const i of String(r).split(" ")) o.push(`rounded-${i}`); else (s || r === !1) && o.push("rounded-0"); return o }) } } const it = Z({ tag: { type: String, default: "div" } }, "tag"), ig = Z({ app: Boolean, color: String, height: { type: [Number, String], default: "auto" }, ...Na(), ...Te(), ...Ha(), ...Xm(), ...$n(), ...it({ tag: "footer" }), ...jt() }, "VFooter"), lg = Ce()({ name: "VFooter", props: ig(), setup(e, t) { let { slots: n } = t; const { themeClasses: r } = Wt(e), { backgroundColorClasses: s, backgroundColorStyles: o } = An(Dt(e, "color")), { borderClasses: i } = Va(e), { elevationClasses: l } = ja(e), { roundedClasses: a } = Nn(e), u = me(32), { resizeRef: c } = Da(h => { h.length && (u.value = h[0].target.clientHeight) }), f = E(() => e.height === "auto" ? u.value : parseInt(e.height, 10)), { layoutItemStyles: m } = Qm({ id: e.name, order: E(() => parseInt(e.order, 10)), position: E(() => "bottom"), layoutSize: f, elementSize: E(() => e.height === "auto" ? void 0 : f.value), active: E(() => e.app), absolute: Dt(e, "absolute") }); return Ne(() => p(e.tag, { ref: c, class: ["v-footer", r.value, s.value, i.value, l.value, a.value, e.class], style: [o.value, e.app ? m.value : { height: J(e.height) }, e.style] }, n)), {} } }), ag = ["x-small", "small", "default", "large", "x-large"], Wa = Z({ size: { type: [String, Number], default: "default" } }, "size"); function za(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : St(); return so(() => { let n, r; return gr(ag, e.size) ? n = `${t}--size-${e.size}` : e.size && (r = { width: J(e.size), height: J(e.size) }), { sizeClasses: n, sizeStyles: r } }) } const ug = Z({ color: String, disabled: Boolean, start: Boolean, end: Boolean, icon: Rt, ...Te(), ...Wa(), ...it({ tag: "i" }), ...jt() }, "VIcon"), br = Ce()({ name: "VIcon", props: ug(), setup(e, t) { let { attrs: n, slots: r } = t; const s = ce(), { themeClasses: o } = Wt(e), { iconData: i } = Ym(E(() => s.value || e.icon)), { sizeClasses: l } = za(e), { textColorClasses: a, textColorStyles: u } = Ba(Dt(e, "color")); return Ne(() => { var m, h; const c = (m = r.default) == null ? void 0 : m.call(r); c && (s.value = (h = va(c).filter(b => b.type === Ln && b.children && typeof b.children == "string")[0]) == null ? void 0 : h.children); const f = !!(n.onClick || n.onClickOnce); return p(i.value.component, { tag: e.tag, icon: i.value.icon, class: ["v-icon", "notranslate", o.value, l.value, a.value, { "v-icon--clickable": f, "v-icon--disabled": e.disabled, "v-icon--start": e.start, "v-icon--end": e.end }, e.class], style: [l.value ? void 0 : { fontSize: J(e.size), height: J(e.size), width: J(e.size) }, u.value, e.style], role: f ? "button" : void 0, "aria-hidden": !f, tabindex: f ? e.disabled ? -1 : 0 : void 0 }, { default: () => [c] }) }), {} } }), Ua = e => (bc("data-v-63683fca"), e = e(), _c(), e), cg = ["href", "title"], fg = { class: "text-caption text-disabled", style: { position: "absolute", right: "16px" } }, dg = Ua(() => je("span", { class: "d-none d-sm-inline-block" }, "Vuetify, LLC", -1)), mg = Ua(() => je("a", { class: "text-decoration-none on-surface", href: "https://vuetifyjs.com/about/licensing/", rel: "noopener noreferrer", target: "_blank" }, " MIT License ", -1)), gg = { __name: "AppFooter", setup(e) { const t = [{ title: "Vuetify Documentation", icon: "$vuetify", href: "https://vuetifyjs.com/" }, { title: "Vuetify Support", icon: "mdi-shield-star-outline", href: "https://support.vuetifyjs.com/" }, { title: "Vuetify X", icon: "svg:M2.04875 3.00002L9.77052 13.3248L1.99998 21.7192H3.74882L10.5519 14.3697L16.0486 21.7192H22L13.8437 10.8137L21.0765 3.00002H19.3277L13.0624 9.76874L8.0001 3.00002H2.04875ZM4.62054 4.28821H7.35461L19.4278 20.4308H16.6937L4.62054 4.28821Z", href: "https://x.com/vuetifyjs" }, { title: "Vuetify GitHub", icon: "mdi-github", href: "https://github.com/vuetifyjs/vuetify" }, { title: "Vuetify Discord", icon: "mdi-discord", href: "https://community.vuetifyjs.com/" }, { title: "Vuetify Reddit", icon: "mdi-reddit", href: "https://reddit.com/r/vuetifyjs" }]; return (n, r) => (ur(), eo(lg, { height: "40", app: "" }, { default: de(() => [(ur(), ff(we, null, Hc(t, s => je("a", { key: s.title, href: s.href, title: s.title, class: "d-inline-block mx-2 social-link", rel: "noopener noreferrer", target: "_blank" }, [p(br, { icon: s.icon, size: s.icon === "$vuetify" ? 24 : 16 }, null, 8, ["icon", "size"])], 8, cg)), 64)), je("div", fg, [ht("  2016-" + sl(new Date().getFullYear()) + " ", 1), dg, ht("  "), mg])]), _: 1 })) } }, hg = og(gg, [["__scopeId", "data-v-63683fca"]]), vg = "/demosite/assets/logo-DtuIbWiQ.png", yg = Ce()({ name: "VCardActions", props: Te(), setup(e, t) { let { slots: n } = t; return xa({ VBtn: { slim: !0, variant: "text" } }), Ne(() => { var r; return p("div", { class: ["v-card-actions", e.class], style: e.style }, [(r = n.default) == null ? void 0 : r.call(n)]) }), {} } }), pg = Rr("v-card-subtitle"), bg = Rr("v-card-title"), _g = Z({ defaults: Object, disabled: Boolean, reset: [Number, String], root: [Boolean, String], scoped: Boolean }, "VDefaultsProvider"), _r = Ce(!1)({ name: "VDefaultsProvider", props: _g(), setup(e, t) { let { slots: n } = t; const { defaults: r, disabled: s, reset: o, root: i, scoped: l } = Us(e); return xa(r, { reset: o, root: i, scoped: l, disabled: s }), () => { var a; return (a = n.default) == null ? void 0 : a.call(n) } } }), fo = Z({ height: [Number, String], maxHeight: [Number, String], maxWidth: [Number, String], minHeight: [Number, String], minWidth: [Number, String], width: [Number, String] }, "dimension"); function mo(e) { return { dimensionStyles: E(() => ({ height: J(e.height), maxHeight: J(e.maxHeight), maxWidth: J(e.maxWidth), minHeight: J(e.minHeight), minWidth: J(e.minWidth), width: J(e.width) })) } } function wg(e) { return { aspectStyles: E(() => { const t = Number(e.aspectRatio); return t ? { paddingBottom: String(1 / t * 100) + "%" } : void 0 }) } } const Ka = Z({ aspectRatio: [String, Number], contentClass: String, inline: Boolean, ...Te(), ...fo() }, "VResponsive"), Ts = Ce()({ name: "VResponsive", props: Ka(), setup(e, t) { let { slots: n } = t; const { aspectStyles: r } = wg(e), { dimensionStyles: s } = mo(e); return Ne(() => { var o; return p("div", { class: ["v-responsive", { "v-responsive--inline": e.inline }, e.class], style: [s.value, e.style] }, [p("div", { class: "v-responsive__sizer", style: r.value }, null), (o = n.additional) == null ? void 0 : o.call(n), n.default && p("div", { class: ["v-responsive__content", e.contentClass] }, [n.default()])]) }), {} } }), Ya = Z({ transition: { type: [Boolean, String, Object], default: "fade-transition", validator: e => e !== !0 } }, "transition"), fn = (e, t) => { let { slots: n } = t; const { transition: r, disabled: s, group: o, ...i } = e, { component: l = o ? Gf : Fn, ...a } = typeof r == "object" ? r : {}; return en(l, Ye(typeof r == "string" ? { name: s ? "" : r } : a, typeof r == "string" ? {} : Object.fromEntries(Object.entries({ disabled: s, group: o }).filter(u => { let [c, f] = u; return f !== void 0 })), i), n) }; function Cg(e, t) { if (!ro) return; const n = t.modifiers || {}, r = t.value, { handler: s, options: o } = typeof r == "object" ? r : { handler: r, options: {} }, i = new IntersectionObserver(function () { var f; let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], a = arguments.length > 1 ? arguments[1] : void 0; const u = (f = e._observe) == null ? void 0 : f[t.instance.$.uid]; if (!u) return; const c = l.some(m => m.isIntersecting); s && (!n.quiet || u.init) && (!n.once || c || u.init) && s(c, l, a), c && n.once ? Ga(e, t) : u.init = !0 }, o); e._observe = Object(e._observe), e._observe[t.instance.$.uid] = { init: !1, observer: i }, i.observe(e) } function Ga(e, t) { var r; const n = (r = e._observe) == null ? void 0 : r[t.instance.$.uid]; n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid]) } const Sg = { mounted: Cg, unmounted: Ga }, xg = Sg, Eg = Z({ alt: String, cover: Boolean, color: String, draggable: { type: [Boolean, String], default: void 0 }, eager: Boolean, gradient: String, lazySrc: String, options: { type: Object, default: () => ({ root: void 0, rootMargin: void 0, threshold: void 0 }) }, sizes: String, src: { type: [String, Object], default: "" }, crossorigin: String, referrerpolicy: String, srcset: String, position: String, ...Ka(), ...Te(), ...$n(), ...Ya() }, "VImg"), wr = Ce()({ name: "VImg", directives: { intersect: xg }, props: Eg(), emits: { loadstart: e => !0, load: e => !0, error: e => !0 }, setup(e, t) { let { emit: n, slots: r } = t; const { backgroundColorClasses: s, backgroundColorStyles: o } = An(Dt(e, "color")), { roundedClasses: i } = Nn(e), l = ke("VImg"), a = me(""), u = ce(), c = me(e.eager ? "loading" : "idle"), f = me(), m = me(), h = E(() => e.src && typeof e.src == "object" ? { src: e.src.src, srcset: e.srcset || e.src.srcset, lazySrc: e.lazySrc || e.src.lazySrc, aspect: Number(e.aspectRatio || e.src.aspect || 0) } : { src: e.src, srcset: e.srcset, lazySrc: e.lazySrc, aspect: Number(e.aspectRatio || 0) }), b = E(() => h.value.aspect || f.value / m.value || 0); oe(() => e.src, () => { v(c.value !== "idle") }), oe(b, (_, P) => { !_ && P && u.value && W(u.value) }), Vl(() => v()); function v(_) { if (!(e.eager && _) && !(ro && !_ && !e.eager)) { if (c.value = "loading", h.value.lazySrc) { const P = new Image; P.src = h.value.lazySrc, W(P, null) } h.value.src && Nt(() => { var P; n("loadstart", ((P = u.value) == null ? void 0 : P.currentSrc) || h.value.src), setTimeout(() => { var N; if (!l.isUnmounted) if ((N = u.value) != null && N.complete) { if (u.value.naturalWidth || $(), c.value === "error") return; b.value || W(u.value, null), c.value === "loading" && L() } else b.value || W(u.value), D() }) }) } } function L() { var _; l.isUnmounted || (D(), W(u.value), c.value = "loaded", n("load", ((_ = u.value) == null ? void 0 : _.currentSrc) || h.value.src)) } function $() { var _; l.isUnmounted || (c.value = "error", n("error", ((_ = u.value) == null ? void 0 : _.currentSrc) || h.value.src)) } function D() { const _ = u.value; _ && (a.value = _.currentSrc || _.src) } let F = -1; Bt(() => { clearTimeout(F) }); function W(_) { let P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100; const N = () => { if (clearTimeout(F), l.isUnmounted) return; const { naturalHeight: ye, naturalWidth: ee } = _; ye || ee ? (f.value = ee, m.value = ye) : !_.complete && c.value === "loading" && P != null ? F = window.setTimeout(N, P) : (_.currentSrc.endsWith(".svg") || _.currentSrc.startsWith("data:image/svg+xml")) && (f.value = 1, m.value = 1) }; N() } const U = E(() => ({ "v-img__img--cover": e.cover, "v-img__img--contain": !e.cover })), A = () => { var N; if (!h.value.src || c.value === "idle") return null; const _ = p("img", { class: ["v-img__img", U.value], style: { objectPosition: e.position }, src: h.value.src, srcset: h.value.srcset, alt: e.alt, crossorigin: e.crossorigin, referrerpolicy: e.referrerpolicy, draggable: e.draggable, sizes: e.sizes, ref: u, onLoad: L, onError: $ }, null), P = (N = r.sources) == null ? void 0 : N.call(r); return p(fn, { transition: e.transition, appear: !0 }, { default: () => [lr(P ? p("picture", { class: "v-img__picture" }, [P, _]) : _, [[ua, c.value === "loaded"]])] }) }, S = () => p(fn, { transition: e.transition }, { default: () => [h.value.lazySrc && c.value !== "loaded" && p("img", { class: ["v-img__img", "v-img__img--preload", U.value], style: { objectPosition: e.position }, src: h.value.lazySrc, alt: e.alt, crossorigin: e.crossorigin, referrerpolicy: e.referrerpolicy, draggable: e.draggable }, null)] }), T = () => r.placeholder ? p(fn, { transition: e.transition, appear: !0 }, { default: () => [(c.value === "loading" || c.value === "error" && !r.error) && p("div", { class: "v-img__placeholder" }, [r.placeholder()])] }) : null, V = () => r.error ? p(fn, { transition: e.transition, appear: !0 }, { default: () => [c.value === "error" && p("div", { class: "v-img__error" }, [r.error()])] }) : null, B = () => e.gradient ? p("div", { class: "v-img__gradient", style: { backgroundImage: `linear-gradient(${e.gradient})` } }, null) : null, H = me(!1); { const _ = oe(b, P => { P && (requestAnimationFrame(() => { requestAnimationFrame(() => { H.value = !0 }) }), _()) }) } return Ne(() => { const _ = Ts.filterProps(e); return lr(p(Ts, Ye({ class: ["v-img", { "v-img--booting": !H.value }, s.value, i.value, e.class], style: [{ width: J(e.width === "auto" ? f.value : e.width) }, o.value, e.style] }, _, { aspectRatio: b.value, "aria-label": e.alt, role: e.alt ? "img" : void 0 }), { additional: () => p(we, null, [p(A, null, null), p(S, null, null), p(B, null, null), p(T, null, null), p(V, null, null)]), default: r.default }), [[Gs("intersect"), { handler: v, options: e.options }, null, { once: !0 }]]) }), { currentSrc: a, image: u, state: c, naturalWidth: f, naturalHeight: m } } }), Tg = [null, "default", "comfortable", "compact"], go = Z({ density: { type: String, default: "default", validator: e => Tg.includes(e) } }, "density"); function qa(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : St(); return { densityClasses: E(() => `${t}--density-${e.density}`) } } const Ag = ["elevated", "flat", "tonal", "outlined", "text", "plain"]; function Za(e, t) { return p(we, null, [e && p("span", { key: "overlay", class: `${t}__overlay` }, null), p("span", { key: "underlay", class: `${t}__underlay` }, null)]) } const Xa = Z({ color: String, variant: { type: String, default: "elevated", validator: e => Ag.includes(e) } }, "variant"); function Ja(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : St(); const n = E(() => { const { variant: o } = vt(e); return `${t}--variant-${o}` }), { colorClasses: r, colorStyles: s } = co(E(() => { const { variant: o, color: i } = vt(e); return { [["elevated", "flat"].includes(o) ? "background" : "text"]: i } })); return { colorClasses: r, colorStyles: s, variantClasses: n } } const Og = Z({ start: Boolean, end: Boolean, icon: Rt, image: String, text: String, ...Te(), ...go(), ...$n(), ...Wa(), ...it(), ...jt(), ...Xa({ variant: "flat" }) }, "VAvatar"), Vi = Ce()({ name: "VAvatar", props: Og(), setup(e, t) { let { slots: n } = t; const { themeClasses: r } = Wt(e), { colorClasses: s, colorStyles: o, variantClasses: i } = Ja(e), { densityClasses: l } = qa(e), { roundedClasses: a } = Nn(e), { sizeClasses: u, sizeStyles: c } = za(e); return Ne(() => p(e.tag, { class: ["v-avatar", { "v-avatar--start": e.start, "v-avatar--end": e.end }, r.value, s.value, l.value, a.value, u.value, i.value, e.class], style: [o.value, c.value, e.style] }, { default: () => [n.default ? p(_r, { key: "content-defaults", defaults: { VImg: { cover: !0, image: e.image }, VIcon: { icon: e.icon } } }, { default: () => [n.default()] }) : e.image ? p(wr, { key: "image", src: e.image, alt: "", cover: !0 }, null) : e.icon ? p(br, { key: "icon", icon: e.icon }, null) : e.text, Za(!1, "v-avatar")] })), {} } }), kg = Z({ appendAvatar: String, appendIcon: Rt, prependAvatar: String, prependIcon: Rt, subtitle: [String, Number], title: [String, Number], ...Te(), ...go() }, "VCardItem"), Pg = Ce()({ name: "VCardItem", props: kg(), setup(e, t) { let { slots: n } = t; return Ne(() => { var u; const r = !!(e.prependAvatar || e.prependIcon), s = !!(r || n.prepend), o = !!(e.appendAvatar || e.appendIcon), i = !!(o || n.append), l = !!(e.title != null || n.title), a = !!(e.subtitle != null || n.subtitle); return p("div", { class: ["v-card-item", e.class], style: e.style }, [s && p("div", { key: "prepend", class: "v-card-item__prepend" }, [n.prepend ? p(_r, { key: "prepend-defaults", disabled: !r, defaults: { VAvatar: { density: e.density, image: e.prependAvatar }, VIcon: { density: e.density, icon: e.prependIcon } } }, n.prepend) : p(we, null, [e.prependAvatar && p(Vi, { key: "prepend-avatar", density: e.density, image: e.prependAvatar }, null), e.prependIcon && p(br, { key: "prepend-icon", density: e.density, icon: e.prependIcon }, null)])]), p("div", { class: "v-card-item__content" }, [l && p(bg, { key: "title" }, { default: () => { var c; return [((c = n.title) == null ? void 0 : c.call(n)) ?? e.title] } }), a && p(pg, { key: "subtitle" }, { default: () => { var c; return [((c = n.subtitle) == null ? void 0 : c.call(n)) ?? e.subtitle] } }), (u = n.default) == null ? void 0 : u.call(n)]), i && p("div", { key: "append", class: "v-card-item__append" }, [n.append ? p(_r, { key: "append-defaults", disabled: !o, defaults: { VAvatar: { density: e.density, image: e.appendAvatar }, VIcon: { density: e.density, icon: e.appendIcon } } }, n.append) : p(we, null, [e.appendIcon && p(br, { key: "append-icon", density: e.density, icon: e.appendIcon }, null), e.appendAvatar && p(Vi, { key: "append-avatar", density: e.density, image: e.appendAvatar }, null)])])]) }), {} } }), Ig = Rr("v-card-text"); function Lg(e, t) { const n = ce(), r = me(!1); if (ro) { const s = new IntersectionObserver(o => { e == null || e(o, s), r.value = !!o.find(i => i.isIntersecting) }, t); Bt(() => { s.disconnect() }), oe(n, (o, i) => { i && (s.unobserve(i), r.value = !1), o && s.observe(o) }, { flush: "post" }) } return { intersectionRef: n, isIntersecting: r } } const Bi = { center: "center", top: "bottom", bottom: "top", left: "right", right: "left" }, Qa = Z({ location: String }, "location"); function eu(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 ? arguments[2] : void 0; const { isRtl: r } = Rn(); return { locationStyles: E(() => { if (!e.location) return {}; const { side: o, align: i } = _s(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, r.value); function l(u) { return n ? n(u) : 0 } const a = {}; return o !== "center" && (t ? a[Bi[o]] = `calc(100% - ${l(o)}px)` : a[o] = 0), i !== "center" ? t ? a[Bi[i]] = `calc(100% - ${l(i)}px)` : a[i] = 0 : (o === "center" ? a.top = a.left = "50%" : a[{ top: "left", bottom: "left", left: "top", right: "top" }[o]] = "50%", a.transform = { top: "translateX(-50%)", bottom: "translateX(-50%)", left: "translateY(-50%)", right: "translateY(-50%)", center: "translate(-50%, -50%)" }[o]), a }) } } const Mg = Z({ absolute: Boolean, active: { type: Boolean, default: !0 }, bgColor: String, bgOpacity: [Number, String], bufferValue: { type: [Number, String], default: 0 }, clickable: Boolean, color: String, height: { type: [Number, String], default: 4 }, indeterminate: Boolean, max: { type: [Number, String], default: 100 }, modelValue: { type: [Number, String], default: 0 }, reverse: Boolean, stream: Boolean, striped: Boolean, roundedBar: Boolean, ...Te(), ...Qa({ location: "top" }), ...$n(), ...it(), ...jt() }, "VProgressLinear"), Fg = Ce()({ name: "VProgressLinear", props: Mg(), emits: { "update:modelValue": e => !0 }, setup(e, t) { let { slots: n } = t; const r = uo(e, "modelValue"), { isRtl: s, rtlClasses: o } = Rn(), { themeClasses: i } = Wt(e), { locationStyles: l } = eu(e), { textColorClasses: a, textColorStyles: u } = Ba(e, "color"), { backgroundColorClasses: c, backgroundColorStyles: f } = An(E(() => e.bgColor || e.color)), { backgroundColorClasses: m, backgroundColorStyles: h } = An(e, "color"), { roundedClasses: b } = Nn(e), { intersectionRef: v, isIntersecting: L } = Lg(), $ = E(() => parseInt(e.max, 10)), D = E(() => parseInt(e.height, 10)), F = E(() => parseFloat(e.bufferValue) / $.value * 100), W = E(() => parseFloat(r.value) / $.value * 100), U = E(() => s.value !== e.reverse), A = E(() => e.indeterminate ? "fade-transition" : "slide-x-transition"), S = E(() => e.bgOpacity == null ? e.bgOpacity : parseFloat(e.bgOpacity)); function T(V) { if (!v.value) return; const { left: B, right: H, width: _ } = v.value.getBoundingClientRect(), P = U.value ? _ - V.clientX + (H - _) : V.clientX - B; r.value = Math.round(P / _ * $.value) } return Ne(() => p(e.tag, { ref: v, class: ["v-progress-linear", { "v-progress-linear--absolute": e.absolute, "v-progress-linear--active": e.active && L.value, "v-progress-linear--reverse": U.value, "v-progress-linear--rounded": e.rounded, "v-progress-linear--rounded-bar": e.roundedBar, "v-progress-linear--striped": e.striped }, b.value, i.value, o.value, e.class], style: [{ bottom: e.location === "bottom" ? 0 : void 0, top: e.location === "top" ? 0 : void 0, height: e.active ? J(D.value) : 0, "--v-progress-linear-height": J(D.value), ...e.absolute ? l.value : {} }, e.style], role: "progressbar", "aria-hidden": e.active ? "false" : "true", "aria-valuemin": "0", "aria-valuemax": e.max, "aria-valuenow": e.indeterminate ? void 0 : W.value, onClick: e.clickable && T }, { default: () => [e.stream && p("div", { key: "stream", class: ["v-progress-linear__stream", a.value], style: { ...u.value, [U.value ? "left" : "right"]: J(-D.value), borderTop: `${J(D.value / 2)} dotted`, opacity: S.value, top: `calc(50% - ${J(D.value / 4)})`, width: J(100 - F.value, "%"), "--v-progress-linear-stream-to": J(D.value * (U.value ? 1 : -1)) } }, null), p("div", { class: ["v-progress-linear__background", c.value], style: [f.value, { opacity: S.value, width: J(e.stream ? F.value : 100, "%") }] }, null), p(Fn, { name: A.value }, { default: () => [e.indeterminate ? p("div", { class: "v-progress-linear__indeterminate" }, [["long", "short"].map(V => p("div", { key: V, class: ["v-progress-linear__indeterminate", V, m.value], style: h.value }, null))]) : p("div", { class: ["v-progress-linear__determinate", m.value], style: [h.value, { width: J(W.value, "%") }] }, null)] }), n.default && p("div", { class: "v-progress-linear__content" }, [n.default({ value: W.value, buffer: F.value })])] })), {} } }), Dg = Z({ loading: [Boolean, String] }, "loader"); function Rg(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : St(); return { loaderClasses: E(() => ({ [`${t}--loading`]: e.loading })) } } function $g(e, t) { var r; let { slots: n } = t; return p("div", { class: `${e.name}__loader` }, [((r = n.default) == null ? void 0 : r.call(n, { color: e.color, isActive: e.active })) || p(Fg, { absolute: e.absolute, active: e.active, color: e.color, height: "2", indeterminate: !0 }, null)]) } const Ng = ["static", "relative", "fixed", "absolute", "sticky"], Vg = Z({ position: { type: String, validator: e => Ng.includes(e) } }, "position"); function Bg(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : St(); return { positionClasses: E(() => e.position ? `${t}--${e.position}` : void 0) } } function Hg() { const e = ke("useRoute"); return E(() => { var t; return (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$route }) } function jg() { var e, t; return (t = (e = ke("useRouter")) == null ? void 0 : e.proxy) == null ? void 0 : t.$router } function Wg(e, t) { var u, c; const n = Tc("RouterLink"), r = E(() => !!(e.href || e.to)), s = E(() => (r == null ? void 0 : r.value) || fi(t, "click") || fi(e, "click")); if (typeof n == "string" || !("useLink" in n)) return { isLink: r, isClickable: s, href: Dt(e, "href") }; const o = E(() => ({ ...e, to: Dt(() => e.to || "") })), i = n.useLink(o.value), l = E(() => e.to ? i : void 0), a = Hg(); return { isLink: r, isClickable: s, route: (u = l.value) == null ? void 0 : u.route, navigate: (c = l.value) == null ? void 0 : c.navigate, isActive: E(() => { var f, m, h; return l.value ? e.exact ? a.value ? ((h = l.value.isExactActive) == null ? void 0 : h.value) && ma(l.value.route.value.query, a.value.query) : ((m = l.value.isExactActive) == null ? void 0 : m.value) ?? !1 : ((f = l.value.isActive) == null ? void 0 : f.value) ?? !1 : !1 }), href: E(() => { var f; return e.to ? (f = l.value) == null ? void 0 : f.route.value.href : e.href }) } } const zg = Z({ href: String, replace: Boolean, to: [String, Object], exact: Boolean }, "router"); let rs = !1; function Ug(e, t) { let n = !1, r, s; ge && (Nt(() => { window.addEventListener("popstate", o), r = e == null ? void 0 : e.beforeEach((i, l, a) => { rs ? n ? t(a) : a() : setTimeout(() => n ? t(a) : a()), rs = !0 }), s = e == null ? void 0 : e.afterEach(() => { rs = !1 }) }), qe(() => { window.removeEventListener("popstate", o), r == null || r(), s == null || s() })); function o(i) { var l; (l = i.state) != null && l.replaced || (n = !0, setTimeout(() => n = !1)) } } const As = Symbol("rippleStop"), Kg = 80; function Hi(e, t) { e.style.transform = t, e.style.webkitTransform = t } function Os(e) { return e.constructor.name === "TouchEvent" } function tu(e) { return e.constructor.name === "KeyboardEvent" } const Yg = function (e, t) { var f; let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = 0, s = 0; if (!tu(e)) { const m = t.getBoundingClientRect(), h = Os(e) ? e.touches[e.touches.length - 1] : e; r = h.clientX - m.left, s = h.clientY - m.top } let o = 0, i = .3; (f = t._ripple) != null && f.circle ? (i = .15, o = t.clientWidth / 2, o = n.center ? o : o + Math.sqrt((r - o) ** 2 + (s - o) ** 2) / 4) : o = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2; const l = `${(t.clientWidth - o * 2) / 2}px`, a = `${(t.clientHeight - o * 2) / 2}px`, u = n.center ? l : `${r - o}px`, c = n.center ? a : `${s - o}px`; return { radius: o, scale: i, x: u, y: c, centerX: l, centerY: a } }, Cr = { show(e, t) { var h; let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}; if (!((h = t == null ? void 0 : t._ripple) != null && h.enabled)) return; const r = document.createElement("span"), s = document.createElement("span"); r.appendChild(s), r.className = "v-ripple__container", n.class && (r.className += ` ${n.class}`); const { radius: o, scale: i, x: l, y: a, centerX: u, centerY: c } = Yg(e, t, n), f = `${o * 2}px`; s.className = "v-ripple__animation", s.style.width = f, s.style.height = f, t.appendChild(r); const m = window.getComputedStyle(t); m && m.position === "static" && (t.style.position = "relative", t.dataset.previousPosition = "static"), s.classList.add("v-ripple__animation--enter"), s.classList.add("v-ripple__animation--visible"), Hi(s, `translate(${l}, ${a}) scale3d(${i},${i},${i})`), s.dataset.activated = String(performance.now()), setTimeout(() => { s.classList.remove("v-ripple__animation--enter"), s.classList.add("v-ripple__animation--in"), Hi(s, `translate(${u}, ${c}) scale3d(1,1,1)`) }, 0) }, hide(e) { var o; if (!((o = e == null ? void 0 : e._ripple) != null && o.enabled)) return; const t = e.getElementsByClassName("v-ripple__animation"); if (t.length === 0) return; const n = t[t.length - 1]; if (n.dataset.isHiding) return; n.dataset.isHiding = "true"; const r = performance.now() - Number(n.dataset.activated), s = Math.max(250 - r, 0); setTimeout(() => { n.classList.remove("v-ripple__animation--in"), n.classList.add("v-ripple__animation--out"), setTimeout(() => { var l; e.getElementsByClassName("v-ripple__animation").length === 1 && e.dataset.previousPosition && (e.style.position = e.dataset.previousPosition, delete e.dataset.previousPosition), ((l = n.parentNode) == null ? void 0 : l.parentNode) === e && e.removeChild(n.parentNode) }, 300) }, s) } }; function nu(e) { return typeof e > "u" || !!e } function On(e) { const t = {}, n = e.currentTarget; if (!(!(n != null && n._ripple) || n._ripple.touched || e[As])) { if (e[As] = !0, Os(e)) n._ripple.touched = !0, n._ripple.isTouch = !0; else if (n._ripple.isTouch) return; if (t.center = n._ripple.centered || tu(e), n._ripple.class && (t.class = n._ripple.class), Os(e)) { if (n._ripple.showTimerCommit) return; n._ripple.showTimerCommit = () => { Cr.show(e, n, t) }, n._ripple.showTimer = window.setTimeout(() => { var r; (r = n == null ? void 0 : n._ripple) != null && r.showTimerCommit && (n._ripple.showTimerCommit(), n._ripple.showTimerCommit = null) }, Kg) } else Cr.show(e, n, t) } } function ji(e) { e[As] = !0 } function Re(e) { const t = e.currentTarget; if (t != null && t._ripple) { if (window.clearTimeout(t._ripple.showTimer), e.type === "touchend" && t._ripple.showTimerCommit) { t._ripple.showTimerCommit(), t._ripple.showTimerCommit = null, t._ripple.showTimer = window.setTimeout(() => { Re(e) }); return } window.setTimeout(() => { t._ripple && (t._ripple.touched = !1) }), Cr.hide(t) } } function ru(e) { const t = e.currentTarget; t != null && t._ripple && (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null), window.clearTimeout(t._ripple.showTimer)) } let kn = !1; function su(e) { !kn && (e.keyCode === ai.enter || e.keyCode === ai.space) && (kn = !0, On(e)) } function ou(e) { kn = !1, Re(e) } function iu(e) { kn && (kn = !1, Re(e)) } function lu(e, t, n) { const { value: r, modifiers: s } = t, o = nu(r); if (o || Cr.hide(e), e._ripple = e._ripple ?? {}, e._ripple.enabled = o, e._ripple.centered = s.center, e._ripple.circle = s.circle, ps(r) && r.class && (e._ripple.class = r.class), o && !n) { if (s.stop) { e.addEventListener("touchstart", ji, { passive: !0 }), e.addEventListener("mousedown", ji); return } e.addEventListener("touchstart", On, { passive: !0 }), e.addEventListener("touchend", Re, { passive: !0 }), e.addEventListener("touchmove", ru, { passive: !0 }), e.addEventListener("touchcancel", Re), e.addEventListener("mousedown", On), e.addEventListener("mouseup", Re), e.addEventListener("mouseleave", Re), e.addEventListener("keydown", su), e.addEventListener("keyup", ou), e.addEventListener("blur", iu), e.addEventListener("dragstart", Re, { passive: !0 }) } else !o && n && au(e) } function au(e) { e.removeEventListener("mousedown", On), e.removeEventListener("touchstart", On), e.removeEventListener("touchend", Re), e.removeEventListener("touchmove", ru), e.removeEventListener("touchcancel", Re), e.removeEventListener("mouseup", Re), e.removeEventListener("mouseleave", Re), e.removeEventListener("keydown", su), e.removeEventListener("keyup", ou), e.removeEventListener("dragstart", Re), e.removeEventListener("blur", iu) } function Gg(e, t) { lu(e, t, !1) } function qg(e) { delete e._ripple, au(e) } function Zg(e, t) { if (t.value === t.oldValue) return; const n = nu(t.oldValue); lu(e, t, n) } const Xg = { mounted: Gg, unmounted: qg, updated: Zg }, Jg = Z({ appendAvatar: String, appendIcon: Rt, disabled: Boolean, flat: Boolean, hover: Boolean, image: String, link: { type: Boolean, default: void 0 }, prependAvatar: String, prependIcon: Rt, ripple: { type: [Boolean, Object], default: !0 }, subtitle: [String, Number], text: [String, Number], title: [String, Number], ...Na(), ...Te(), ...go(), ...fo(), ...Ha(), ...Dg(), ...Qa(), ...Vg(), ...$n(), ...zg(), ...it(), ...jt(), ...Xa({ variant: "elevated" }) }, "VCard"), on = Ce()({ name: "VCard", directives: { Ripple: Xg }, props: Jg(), setup(e, t) { let { attrs: n, slots: r } = t; const { themeClasses: s } = Wt(e), { borderClasses: o } = Va(e), { colorClasses: i, colorStyles: l, variantClasses: a } = Ja(e), { densityClasses: u } = qa(e), { dimensionStyles: c } = mo(e), { elevationClasses: f } = ja(e), { loaderClasses: m } = Rg(e), { locationStyles: h } = eu(e), { positionClasses: b } = Bg(e), { roundedClasses: v } = Nn(e), L = Wg(e, n), $ = E(() => e.link !== !1 && L.isLink.value), D = E(() => !e.disabled && e.link !== !1 && (e.link || L.isClickable.value)); return Ne(() => { const F = $.value ? "a" : e.tag, W = !!(r.title || e.title != null), U = !!(r.subtitle || e.subtitle != null), A = W || U, S = !!(r.append || e.appendAvatar || e.appendIcon), T = !!(r.prepend || e.prependAvatar || e.prependIcon), V = !!(r.image || e.image), B = A || T || S, H = !!(r.text || e.text != null); return lr(p(F, { class: ["v-card", { "v-card--disabled": e.disabled, "v-card--flat": e.flat, "v-card--hover": e.hover && !(e.disabled || e.flat), "v-card--link": D.value }, s.value, o.value, i.value, u.value, f.value, m.value, b.value, v.value, a.value, e.class], style: [l.value, c.value, h.value, e.style], href: L.href.value, onClick: D.value && L.navigate, tabindex: e.disabled ? -1 : void 0 }, { default: () => { var _; return [V && p("div", { key: "image", class: "v-card__image" }, [r.image ? p(_r, { key: "image-defaults", disabled: !e.image, defaults: { VImg: { cover: !0, src: e.image } } }, r.image) : p(wr, { key: "image-img", cover: !0, src: e.image }, null)]), p($g, { name: "v-card", active: !!e.loading, color: typeof e.loading == "boolean" ? void 0 : e.loading }, { default: r.loader }), B && p(Pg, { key: "item", prependAvatar: e.prependAvatar, prependIcon: e.prependIcon, title: e.title, subtitle: e.subtitle, appendAvatar: e.appendAvatar, appendIcon: e.appendIcon }, { default: r.item, prepend: r.prepend, title: r.title, subtitle: r.subtitle, append: r.append }), H && p(Ig, { key: "text" }, { default: () => { var P; return [((P = r.text) == null ? void 0 : P.call(r)) ?? e.text] } }), (_ = r.default) == null ? void 0 : _.call(r), r.actions && p(yg, null, { default: r.actions }), Za(D.value, "v-card")] } }), [[Gs("ripple"), D.value && e.ripple]]) }), {} } }), Qg = Z({ fluid: { type: Boolean, default: !1 }, ...Te(), ...it() }, "VContainer"), eh = Ce()({ name: "VContainer", props: Qg(), setup(e, t) { let { slots: n } = t; const { rtlClasses: r } = Rn(); return Ne(() => p(e.tag, { class: ["v-container", { "v-container--fluid": e.fluid }, r.value, e.class], style: e.style }, n)), {} } }), uu = $r.reduce((e, t) => (e[t] = { type: [Boolean, String, Number], default: !1 }, e), {}), cu = $r.reduce((e, t) => { const n = "offset" + st(t); return e[n] = { type: [String, Number], default: null }, e }, {}), fu = $r.reduce((e, t) => { const n = "order" + st(t); return e[n] = { type: [String, Number], default: null }, e }, {}), Wi = { col: Object.keys(uu), offset: Object.keys(cu), order: Object.keys(fu) }; function th(e, t, n) { let r = e; if (!(n == null || n === !1)) { if (t) { const s = t.replace(e, ""); r += `-${s}` } return e === "col" && (r = "v-" + r), e === "col" && (n === "" || n === !0) || (r += `-${n}`), r.toLowerCase() } } const nh = ["auto", "start", "end", "center", "baseline", "stretch"], rh = Z({ cols: { type: [Boolean, String, Number], default: !1 }, ...uu, offset: { type: [String, Number], default: null }, ...cu, order: { type: [String, Number], default: null }, ...fu, alignSelf: { type: String, default: null, validator: e => nh.includes(e) }, ...Te(), ...it() }, "VCol"), ln = Ce()({ name: "VCol", props: rh(), setup(e, t) { let { slots: n } = t; const r = E(() => { const s = []; let o; for (o in Wi) Wi[o].forEach(l => { const a = e[l], u = th(o, l, a); u && s.push(u) }); const i = s.some(l => l.startsWith("v-col-")); return s.push({ "v-col": !i || !e.cols, [`v-col-${e.cols}`]: e.cols, [`offset-${e.offset}`]: e.offset, [`order-${e.order}`]: e.order, [`align-self-${e.alignSelf}`]: e.alignSelf }), s }); return () => { var s; return en(e.tag, { class: [r.value, e.class], style: e.style }, (s = n.default) == null ? void 0 : s.call(n)) } } }), ho = ["start", "end", "center"], du = ["space-between", "space-around", "space-evenly"]; function vo(e, t) { return $r.reduce((n, r) => { const s = e + st(r); return n[s] = t(), n }, {}) } const sh = [...ho, "baseline", "stretch"], mu = e => sh.includes(e), gu = vo("align", () => ({ type: String, default: null, validator: mu })), oh = [...ho, ...du], hu = e => oh.includes(e), vu = vo("justify", () => ({ type: String, default: null, validator: hu })), ih = [...ho, ...du, "stretch"], yu = e => ih.includes(e), pu = vo("alignContent", () => ({ type: String, default: null, validator: yu })), zi = { align: Object.keys(gu), justify: Object.keys(vu), alignContent: Object.keys(pu) }, lh = { align: "align", justify: "justify", alignContent: "align-content" }; function ah(e, t, n) { let r = lh[e]; if (n != null) { if (t) { const s = t.replace(e, ""); r += `-${s}` } return r += `-${n}`, r.toLowerCase() } } const uh = Z({ dense: Boolean, noGutters: Boolean, align: { type: String, default: null, validator: mu }, ...gu, justify: { type: String, default: null, validator: hu }, ...vu, alignContent: { type: String, default: null, validator: yu }, ...pu, ...Te(), ...it() }, "VRow"), ch = Ce()({ name: "VRow", props: uh(), setup(e, t) { let { slots: n } = t; const r = E(() => { const s = []; let o; for (o in zi) zi[o].forEach(i => { const l = e[i], a = ah(o, i, l); a && s.push(a) }); return s.push({ "v-row--no-gutters": e.noGutters, "v-row--dense": e.dense, [`align-${e.align}`]: e.align, [`justify-${e.justify}`]: e.justify, [`align-content-${e.alignContent}`]: e.alignContent }), s }); return () => { var s; return en(e.tag, { class: ["v-row", r.value, e.class], style: e.style }, (s = n.default) == null ? void 0 : s.call(n)) } } }), Ui = Rr("v-kbd"); function ss(e, t) { return { x: e.x + t.x, y: e.y + t.y } } function fh(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function Ki(e, t) { if (e.side === "top" || e.side === "bottom") { const { side: n, align: r } = e, s = r === "left" ? 0 : r === "center" ? t.width / 2 : r === "right" ? t.width : r, o = n === "top" ? 0 : n === "bottom" ? t.height : n; return ss({ x: s, y: o }, t) } else if (e.side === "left" || e.side === "right") { const { side: n, align: r } = e, s = n === "left" ? 0 : n === "right" ? t.width : n, o = r === "top" ? 0 : r === "center" ? t.height / 2 : r === "bottom" ? t.height : r; return ss({ x: s, y: o }, t) } return ss({ x: t.width / 2, y: t.height / 2 }, t) } const bu = { static: gh, connected: vh }, dh = Z({ locationStrategy: { type: [String, Function], default: "static", validator: e => typeof e == "function" || e in bu }, location: { type: String, default: "bottom" }, origin: { type: String, default: "auto" }, offset: [Number, String, Array] }, "VOverlay-location-strategies"); function mh(e, t) { const n = ce({}), r = ce(); ge && Dr(() => !!(t.isActive.value && e.locationStrategy), o => { var i, l; oe(() => e.locationStrategy, o), qe(() => { window.removeEventListener("resize", s), r.value = void 0 }), window.addEventListener("resize", s, { passive: !0 }), typeof e.locationStrategy == "function" ? r.value = (i = e.locationStrategy(t, e, n)) == null ? void 0 : i.updateLocation : r.value = (l = bu[e.locationStrategy](t, e, n)) == null ? void 0 : l.updateLocation }); function s(o) { var i; (i = r.value) == null || i.call(r, o) } return { contentStyles: n, updateLocation: r } } function gh() { } function hh(e, t) { t ? e.style.removeProperty("left") : e.style.removeProperty("right"); const n = md(e); return t ? n.x += parseFloat(e.style.right || 0) : n.x -= parseFloat(e.style.left || 0), n.y -= parseFloat(e.style.top || 0), n } function vh(e, t, n) { (Array.isArray(e.target.value) || Ud(e.target.value)) && Object.assign(n.value, { position: "fixed", top: 0, [e.isRtl.value ? "right" : "left"]: 0 }); const { preferredAnchor: s, preferredOrigin: o } = so(() => { const b = _s(t.location, e.isRtl.value), v = t.origin === "overlap" ? b : t.origin === "auto" ? es(b) : _s(t.origin, e.isRtl.value); return b.side === v.side && b.align === ts(v).align ? { preferredAnchor: mi(b), preferredOrigin: mi(v) } : { preferredAnchor: b, preferredOrigin: v } }), [i, l, a, u] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map(b => E(() => { const v = parseFloat(t[b]); return isNaN(v) ? 1 / 0 : v })), c = E(() => { if (Array.isArray(t.offset)) return t.offset; if (typeof t.offset == "string") { const b = t.offset.split(" ").map(parseFloat); return b.length < 2 && b.push(0), b } return typeof t.offset == "number" ? [t.offset, 0] : [0, 0] }); let f = !1; const m = new ResizeObserver(() => { f && h() }); oe([e.target, e.contentEl], (b, v) => { let [L, $] = b, [D, F] = v; D && !Array.isArray(D) && m.unobserve(D), L && !Array.isArray(L) && m.observe(L), F && m.unobserve(F), $ && m.observe($) }, { immediate: !0 }), qe(() => { m.disconnect() }); function h() { if (f = !1, requestAnimationFrame(() => f = !0), !e.target.value || !e.contentEl.value) return; const b = dd(e.target.value), v = hh(e.contentEl.value, e.isRtl.value), L = vr(e.contentEl.value), $ = 12; L.length || (L.push(document.documentElement), e.contentEl.value.style.top && e.contentEl.value.style.left || (v.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), v.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0))); const D = L.reduce((H, _) => { const P = _.getBoundingClientRect(), N = new Ft({ x: _ === document.documentElement ? 0 : P.x, y: _ === document.documentElement ? 0 : P.y, width: _.clientWidth, height: _.clientHeight }); return H ? new Ft({ x: Math.max(H.left, N.left), y: Math.max(H.top, N.top), width: Math.min(H.right, N.right) - Math.max(H.left, N.left), height: Math.min(H.bottom, N.bottom) - Math.max(H.top, N.top) }) : N }, void 0); D.x += $, D.y += $, D.width -= $ * 2, D.height -= $ * 2; let F = { anchor: s.value, origin: o.value }; function W(H) { const _ = new Ft(v), P = Ki(H.anchor, b), N = Ki(H.origin, _); let { x: ye, y: ee } = fh(P, N); switch (H.anchor.side) { case "top": ee -= c.value[0]; break; case "bottom": ee += c.value[0]; break; case "left": ye -= c.value[0]; break; case "right": ye += c.value[0]; break }switch (H.anchor.align) { case "top": ee -= c.value[1]; break; case "bottom": ee += c.value[1]; break; case "left": ye -= c.value[1]; break; case "right": ye += c.value[1]; break }return _.x += ye, _.y += ee, _.width = Math.min(_.width, a.value), _.height = Math.min(_.height, u.value), { overflows: hi(_, D), x: ye, y: ee } } let U = 0, A = 0; const S = { x: 0, y: 0 }, T = { x: !1, y: !1 }; let V = -1; for (; !(V++ > 10);) { const { x: H, y: _, overflows: P } = W(F); U += H, A += _, v.x += H, v.y += _; { const N = gi(F.anchor), ye = P.x.before || P.x.after, ee = P.y.before || P.y.after; let ne = !1; if (["x", "y"].forEach(Y => { if (Y === "x" && ye && !T.x || Y === "y" && ee && !T.y) { const fe = { anchor: { ...F.anchor }, origin: { ...F.origin } }, We = Y === "x" ? N === "y" ? ts : es : N === "y" ? es : ts; fe.anchor = We(fe.anchor), fe.origin = We(fe.origin); const { overflows: Se } = W(fe); (Se[Y].before <= P[Y].before && Se[Y].after <= P[Y].after || Se[Y].before + Se[Y].after < (P[Y].before + P[Y].after) / 2) && (F = fe, ne = T[Y] = !0) } }), ne) continue } P.x.before && (U += P.x.before, v.x += P.x.before), P.x.after && (U -= P.x.after, v.x -= P.x.after), P.y.before && (A += P.y.before, v.y += P.y.before), P.y.after && (A -= P.y.after, v.y -= P.y.after); { const N = hi(v, D); S.x = D.width - N.x.before - N.x.after, S.y = D.height - N.y.before - N.y.after, U += N.x.before, v.x += N.x.before, A += N.y.before, v.y += N.y.before } break } const B = gi(F.anchor); return Object.assign(n.value, { "--v-overlay-anchor-origin": `${F.anchor.side} ${F.anchor.align}`, transformOrigin: `${F.origin.side} ${F.origin.align}`, top: J(os(A)), left: e.isRtl.value ? void 0 : J(os(U)), right: e.isRtl.value ? J(os(-U)) : void 0, minWidth: J(B === "y" ? Math.min(i.value, b.width) : i.value), maxWidth: J(Yi(bs(S.x, i.value === 1 / 0 ? 0 : i.value, a.value))), maxHeight: J(Yi(bs(S.y, l.value === 1 / 0 ? 0 : l.value, u.value))) }), { available: S, contentBox: v } } return oe(() => [s.value, o.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight], () => h()), Nt(() => { const b = h(); if (!b) return; const { available: v, contentBox: L } = b; L.height > v.y && requestAnimationFrame(() => { h(), requestAnimationFrame(() => { h() }) }) }), { updateLocation: h } } function os(e) { return Math.round(e * devicePixelRatio) / devicePixelRatio } function Yi(e) { return Math.ceil(e * devicePixelRatio) / devicePixelRatio } let ks = !0; const Sr = []; function yh(e) { !ks || Sr.length ? (Sr.push(e), Ps()) : (ks = !1, e(), Ps()) } let Gi = -1; function Ps() { cancelAnimationFrame(Gi), Gi = requestAnimationFrame(() => { const e = Sr.shift(); e && e(), Sr.length ? Ps() : ks = !0 }) } const rr = { none: null, close: _h, block: wh, reposition: Ch }, ph = Z({ scrollStrategy: { type: [String, Function], default: "block", validator: e => typeof e == "function" || e in rr } }, "VOverlay-scroll-strategies"); function bh(e, t) { if (!ge) return; let n; Vt(async () => { n == null || n.stop(), t.isActive.value && e.scrollStrategy && (n = $s(), await new Promise(r => setTimeout(r)), n.active && n.run(() => { var r; typeof e.scrollStrategy == "function" ? e.scrollStrategy(t, e, n) : (r = rr[e.scrollStrategy]) == null || r.call(rr, t, e, n) })) }), qe(() => { n == null || n.stop() }) } function _h(e) { function t(n) { e.isActive.value = !1 } _u(e.targetEl.value ?? e.contentEl.value, t) } function wh(e, t) { var i; const n = (i = e.root.value) == null ? void 0 : i.offsetParent, r = [...new Set([...vr(e.targetEl.value, t.contained ? n : void 0), ...vr(e.contentEl.value, t.contained ? n : void 0)])].filter(l => !l.classList.contains("v-overlay-scroll-blocked")), s = window.innerWidth - document.documentElement.offsetWidth, o = (l => ao(l) && l)(n || document.documentElement); o && e.root.value.classList.add("v-overlay--scroll-blocked"), r.forEach((l, a) => { l.style.setProperty("--v-body-scroll-x", J(-l.scrollLeft)), l.style.setProperty("--v-body-scroll-y", J(-l.scrollTop)), l !== document.documentElement && l.style.setProperty("--v-scrollbar-offset", J(s)), l.classList.add("v-overlay-scroll-blocked") }), qe(() => { r.forEach((l, a) => { const u = parseFloat(l.style.getPropertyValue("--v-body-scroll-x")), c = parseFloat(l.style.getPropertyValue("--v-body-scroll-y")), f = l.style.scrollBehavior; l.style.scrollBehavior = "auto", l.style.removeProperty("--v-body-scroll-x"), l.style.removeProperty("--v-body-scroll-y"), l.style.removeProperty("--v-scrollbar-offset"), l.classList.remove("v-overlay-scroll-blocked"), l.scrollLeft = -u, l.scrollTop = -c, l.style.scrollBehavior = f }), o && e.root.value.classList.remove("v-overlay--scroll-blocked") }) } function Ch(e, t, n) { let r = !1, s = -1, o = -1; function i(l) { yh(() => { var c, f; const a = performance.now(); (f = (c = e.updateLocation).value) == null || f.call(c, l), r = (performance.now() - a) / (1e3 / 60) > 2 }) } o = (typeof requestIdleCallback > "u" ? l => l() : requestIdleCallback)(() => { n.run(() => { _u(e.targetEl.value ?? e.contentEl.value, l => { r ? (cancelAnimationFrame(s), s = requestAnimationFrame(() => { s = requestAnimationFrame(() => { i(l) }) })) : i(l) }) }) }), qe(() => { typeof cancelIdleCallback < "u" && cancelIdleCallback(o), cancelAnimationFrame(s) }) } function _u(e, t) { const n = [document, ...vr(e)]; n.forEach(r => { r.addEventListener("scroll", t, { passive: !0 }) }), qe(() => { n.forEach(r => { r.removeEventListener("scroll", t) }) }) } const Sh = Symbol.for("vuetify:v-menu"), xh = Z({ closeDelay: [Number, String], openDelay: [Number, String] }, "delay"); function Eh(e, t) { let n = () => { }; function r(i) { n == null || n(); const l = Number(i ? e.openDelay : e.closeDelay); return new Promise(a => { n = cd(l, () => { t == null || t(i), a(i) }) }) } function s() { return r(!0) } function o() { return r(!1) } return { clearDelay: n, runOpenDelay: s, runCloseDelay: o } } const Th = Z({ target: [String, Object], activator: [String, Object], activatorProps: { type: Object, default: () => ({}) }, openOnClick: { type: Boolean, default: void 0 }, openOnHover: Boolean, openOnFocus: { type: Boolean, default: void 0 }, closeOnContentClick: Boolean, ...xh() }, "VOverlay-activator"); function Ah(e, t) { let { isActive: n, isTop: r } = t; const s = ke("useActivator"), o = ce(); let i = !1, l = !1, a = !0; const u = E(() => e.openOnFocus || e.openOnFocus == null && e.openOnHover), c = E(() => e.openOnClick || e.openOnClick == null && !e.openOnHover && !u.value), { runOpenDelay: f, runCloseDelay: m } = Eh(e, S => { S === (e.openOnHover && i || u.value && l) && !(e.openOnHover && n.value && !r.value) && (n.value !== S && (a = !0), n.value = S) }), h = ce(), b = { onClick: S => { S.stopPropagation(), o.value = S.currentTarget || S.target, n.value || (h.value = [S.clientX, S.clientY]), n.value = !n.value }, onMouseenter: S => { var T; (T = S.sourceCapabilities) != null && T.firesTouchEvents || (i = !0, o.value = S.currentTarget || S.target, f()) }, onMouseleave: S => { i = !1, m() }, onFocus: S => { ud(S.target, ":focus-visible") !== !1 && (l = !0, S.stopPropagation(), o.value = S.currentTarget || S.target, f()) }, onBlur: S => { l = !1, S.stopPropagation(), m() } }, v = E(() => { const S = {}; return c.value && (S.onClick = b.onClick), e.openOnHover && (S.onMouseenter = b.onMouseenter, S.onMouseleave = b.onMouseleave), u.value && (S.onFocus = b.onFocus, S.onBlur = b.onBlur), S }), L = E(() => { const S = {}; if (e.openOnHover && (S.onMouseenter = () => { i = !0, f() }, S.onMouseleave = () => { i = !1, m() }), u.value && (S.onFocusin = () => { l = !0, f() }, S.onFocusout = () => { l = !1, m() }), e.closeOnContentClick) { const T = Le(Sh, null); S.onClick = () => { n.value = !1, T == null || T.closeParents() } } return S }), $ = E(() => { const S = {}; return e.openOnHover && (S.onMouseenter = () => { a && (i = !0, a = !1, f()) }, S.onMouseleave = () => { i = !1, m() }), S }); oe(r, S => { S && (e.openOnHover && !i && (!u.value || !l) || u.value && !l && (!e.openOnHover || !i)) && (n.value = !1) }), oe(n, S => { S || setTimeout(() => { h.value = void 0 }) }, { flush: "post" }); const D = ce(); Vt(() => { D.value && Nt(() => { o.value = mr(D.value) }) }); const F = ce(), W = E(() => e.target === "cursor" && h.value ? h.value : F.value ? mr(F.value) : wu(e.target, s) || o.value), U = E(() => Array.isArray(W.value) ? void 0 : W.value); let A; return oe(() => !!e.activator, S => { S && ge ? (A = $s(), A.run(() => { Oh(e, s, { activatorEl: o, activatorEvents: v }) })) : A && A.stop() }, { flush: "post", immediate: !0 }), qe(() => { A == null || A.stop() }), { activatorEl: o, activatorRef: D, target: W, targetEl: U, targetRef: F, activatorEvents: v, contentEvents: L, scrimEvents: $ } } function Oh(e, t, n) { let { activatorEl: r, activatorEvents: s } = n; oe(() => e.activator, (a, u) => { if (u && a !== u) { const c = l(u); c && i(c) } a && Nt(() => o()) }, { immediate: !0 }), oe(() => e.activatorProps, () => { o() }), qe(() => { i() }); function o() { let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : l(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps; a && hd(a, Ye(s.value, u)) } function i() { let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : l(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps; a && vd(a, Ye(s.value, u)) } function l() { let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator; const u = wu(a, t); return r.value = (u == null ? void 0 : u.nodeType) === Node.ELEMENT_NODE ? u : void 0, r.value } } function wu(e, t) { var r, s; if (!e) return; let n; if (e === "parent") { let o = (s = (r = t == null ? void 0 : t.proxy) == null ? void 0 : r.$el) == null ? void 0 : s.parentNode; for (; o != null && o.hasAttribute("data-no-activator");)o = o.parentNode; n = o } else typeof e == "string" ? n = document.querySelector(e) : "$el" in e ? n = e.$el : n = e; return n } function kh() { if (!ge) return me(!1); const { ssr: e } = Vm(); if (e) { const t = me(!1); return In(() => { t.value = !0 }), t } else return me(!0) } const Ph = Z({ eager: Boolean }, "lazy"); function Ih(e, t) { const n = me(!1), r = E(() => n.value || e.eager || t.value); oe(t, () => n.value = !0); function s() { e.eager || (n.value = !1) } return { isBooted: n, hasContent: r, onAfterLeave: s } } function Lh() { const t = ke("useScopeId").vnode.scopeId; return { scopeId: t ? { [t]: "" } : void 0 } } const qi = Symbol.for("vuetify:stack"), an = Ie([]); function Mh(e, t, n) { const r = ke("useStack"), s = !n, o = Le(qi, void 0), i = Ie({ activeChildren: new Set }); Ht(qi, i); const l = me(+t.value); Dr(e, () => { var f; const c = (f = an.at(-1)) == null ? void 0 : f[1]; l.value = c ? c + 10 : +t.value, s && an.push([r.uid, l.value]), o == null || o.activeChildren.add(r.uid), qe(() => { if (s) { const m = Q(an).findIndex(h => h[0] === r.uid); an.splice(m, 1) } o == null || o.activeChildren.delete(r.uid) }) }); const a = me(!0); s && Vt(() => { var f; const c = ((f = an.at(-1)) == null ? void 0 : f[0]) === r.uid; setTimeout(() => a.value = c) }); const u = E(() => !i.activeChildren.size); return { globalTop: Pn(a), localTop: u, stackStyles: E(() => ({ zIndex: l.value })) } } function Fh(e) { return { teleportTarget: E(() => { const n = e.value; if (n === !0 || !ge) return; const r = n === !1 ? document.body : typeof n == "string" ? document.querySelector(n) : n; if (r == null) return; let s = r.querySelector(":scope > .v-overlay-container"); return s || (s = document.createElement("div"), s.className = "v-overlay-container", r.appendChild(s)), s }) } } function Dh() { return !0 } function Cu(e, t, n) { if (!e || Su(e, n) === !1) return !1; const r = Ea(t); if (typeof ShadowRoot < "u" && r instanceof ShadowRoot && r.host === e.target) return !1; const s = (typeof n.value == "object" && n.value.include || (() => []))(); return s.push(t), !s.some(o => o == null ? void 0 : o.contains(e.target)) } function Su(e, t) { return (typeof t.value == "object" && t.value.closeConditional || Dh)(e) } function Rh(e, t, n) { const r = typeof n.value == "function" ? n.value : n.value.handler; t._clickOutside.lastMousedownWasOutside && Cu(e, t, n) && setTimeout(() => { Su(e, n) && r && r(e) }, 0) } function Zi(e, t) { const n = Ea(e); t(document), typeof ShadowRoot < "u" && n instanceof ShadowRoot && t(n) } const $h = { mounted(e, t) { const n = s => Rh(s, e, t), r = s => { e._clickOutside.lastMousedownWasOutside = Cu(s, e, t) }; Zi(e, s => { s.addEventListener("click", n, !0), s.addEventListener("mousedown", r, !0) }), e._clickOutside || (e._clickOutside = { lastMousedownWasOutside: !1 }), e._clickOutside[t.instance.$.uid] = { onClick: n, onMousedown: r } }, unmounted(e, t) { e._clickOutside && (Zi(e, n => { var o; if (!n || !((o = e._clickOutside) != null && o[t.instance.$.uid])) return; const { onClick: r, onMousedown: s } = e._clickOutside[t.instance.$.uid]; n.removeEventListener("click", r, !0), n.removeEventListener("mousedown", s, !0) }), delete e._clickOutside[t.instance.$.uid]) } }; function Nh(e) { const { modelValue: t, color: n, ...r } = e; return p(Fn, { name: "fade-transition", appear: !0 }, { default: () => [e.modelValue && p("div", Ye({ class: ["v-overlay__scrim", e.color.backgroundColorClasses.value], style: e.color.backgroundColorStyles.value }, r), null)] }) } const Vh = Z({ absolute: Boolean, attach: [Boolean, String, Object], closeOnBack: { type: Boolean, default: !0 }, contained: Boolean, contentClass: null, contentProps: null, disabled: Boolean, opacity: [Number, String], noClickAnimation: Boolean, modelValue: Boolean, persistent: Boolean, scrim: { type: [Boolean, String], default: !0 }, zIndex: { type: [Number, String], default: 2e3 }, ...Th(), ...Te(), ...fo(), ...Ph(), ...dh(), ...ph(), ...jt(), ...Ya() }, "VOverlay"), un = Ce()({ name: "VOverlay", directives: { ClickOutside: $h }, inheritAttrs: !1, props: { _disableGlobalStack: Boolean, ...Vh() }, emits: { "click:outside": e => !0, "update:modelValue": e => !0, afterEnter: () => !0, afterLeave: () => !0 }, setup(e, t) { let { slots: n, attrs: r, emit: s } = t; const o = uo(e, "modelValue"), i = E({ get: () => o.value, set: le => { le && e.disabled || (o.value = le) } }), { teleportTarget: l } = Fh(E(() => e.attach || e.contained)), { themeClasses: a } = Wt(e), { rtlClasses: u, isRtl: c } = Rn(), { hasContent: f, onAfterLeave: m } = Ih(e, i), h = An(E(() => typeof e.scrim == "string" ? e.scrim : null)), { globalTop: b, localTop: v, stackStyles: L } = Mh(i, Dt(e, "zIndex"), e._disableGlobalStack), { activatorEl: $, activatorRef: D, target: F, targetEl: W, targetRef: U, activatorEvents: A, contentEvents: S, scrimEvents: T } = Ah(e, { isActive: i, isTop: v }), { dimensionStyles: V } = mo(e), B = kh(), { scopeId: H } = Lh(); oe(() => e.disabled, le => { le && (i.value = !1) }); const _ = ce(), P = ce(), N = ce(), { contentStyles: ye, updateLocation: ee } = mh(e, { isRtl: c, contentEl: N, target: F, isActive: i }); bh(e, { root: _, contentEl: N, targetEl: W, isActive: i, updateLocation: ee }); function ne(le) { s("click:outside", le), e.persistent ? pe() : i.value = !1 } function Y(le) { return i.value && b.value && (!e.scrim || le.target === P.value) } ge && oe(i, le => { le ? window.addEventListener("keydown", fe) : window.removeEventListener("keydown", fe) }, { immediate: !0 }), Bt(() => { ge && window.removeEventListener("keydown", fe) }); function fe(le) { var re, ze; le.key === "Escape" && b.value && (e.persistent ? pe() : (i.value = !1, (re = N.value) != null && re.contains(document.activeElement) && ((ze = $.value) == null || ze.focus()))) } const We = jg(); Dr(() => e.closeOnBack, () => { Ug(We, le => { b.value && i.value ? (le(!1), e.persistent ? pe() : i.value = !1) : le() }) }); const Se = ce(); oe(() => i.value && (e.absolute || e.contained) && l.value == null, le => { if (le) { const re = jd(_.value); re && re !== document.scrollingElement && (Se.value = re.scrollTop) } }); function pe() { e.noClickAnimation || N.value && gd(N.value, [{ transformOrigin: "center" }, { transform: "scale(1.03)" }, { transformOrigin: "center" }], { duration: 150, easing: Hd }) } function lt() { s("afterEnter") } function tn() { m(), s("afterLeave") } return Ne(() => { var le; return p(we, null, [(le = n.activator) == null ? void 0 : le.call(n, { isActive: i.value, props: Ye({ ref: D, targetRef: U }, A.value, e.activatorProps) }), B.value && f.value && p(uf, { disabled: !l.value, to: l.value }, { default: () => [p("div", Ye({ class: ["v-overlay", { "v-overlay--absolute": e.absolute || e.contained, "v-overlay--active": i.value, "v-overlay--contained": e.contained }, a.value, u.value, e.class], style: [L.value, { "--v-overlay-opacity": e.opacity, top: J(Se.value) }, e.style], ref: _ }, H, r), [p(Nh, Ye({ color: h, modelValue: i.value && !!e.scrim, ref: P }, T.value), null), p(fn, { appear: !0, persisted: !0, transition: e.transition, target: F.value, onAfterEnter: lt, onAfterLeave: tn }, { default: () => { var re; return [lr(p("div", Ye({ ref: N, class: ["v-overlay__content", e.contentClass], style: [V.value, ye.value] }, S.value, e.contentProps), [(re = n.default) == null ? void 0 : re.call(n, { isActive: i })]), [[ua, i.value], [Gs("click-outside"), { handler: ne, closeConditional: Y, include: () => [$.value] }]])] } })])] })]) }), { activatorEl: $, scrimEl: P, target: F, animateClick: pe, contentEl: N, globalTop: b, localTop: v, updateLocation: ee } } }), Bh = je("div", { class: "text-center" }, [je("div", { class: "text-body-2 font-weight-light mb-n1" }, "Welcome to"), je("h1", { class: "text-h2 font-weight-bold" }, "Vuetify")], -1), Hh = je("div", { class: "py-4" }, null, -1), jh = je("h2", { class: "text-h5 font-weight-bold" }, "Get started", -1), Wh = { class: "text-subtitle-1" }, zh = { __name: "HelloWorld", setup(e) { return (t, n) => (ur(), eo(eh, { class: "fill-height" }, { default: de(() => [p(Ts, { class: "align-centerfill-height mx-auto", "max-width": "900" }, { default: de(() => [p(wr, { class: "mb-4", height: "150", src: vg }), Bh, Hh, p(ch, null, { default: de(() => [p(ln, { cols: "12" }, { default: de(() => [p(on, { class: "py-4", color: "surface-variant", image: "https://cdn.vuetifyjs.com/docs/images/one/create/feature.png", "prepend-icon": "mdi-rocket-launch-outline", rounded: "lg", variant: "outlined" }, { image: de(() => [p(wr, { position: "top right" })]), title: de(() => [jh]), subtitle: de(() => [je("div", Wh, [ht(" Change this page by updating "), p(Ui, null, { default: de(() => [ht(sl("<HelloWorld />"))]), _: 1 }), ht(" in "), p(Ui, null, { default: de(() => [ht("components/HelloWorld.vue")]), _: 1 }), ht(". ")])]), default: de(() => [p(un, { opacity: ".12", scrim: "primary", contained: "", "model-value": "", persistent: "" })]), _: 1 })]), _: 1 }), p(ln, { cols: "6" }, { default: de(() => [p(on, { "append-icon": "mdi-open-in-new", class: "py-4", color: "surface-variant", href: "https://vuetifyjs.com/", "prepend-icon": "mdi-text-box-outline", rel: "noopener noreferrer", rounded: "lg", subtitle: "Learn about all things Vuetify in our documentation.", target: "_blank", title: "Documentation", variant: "text" }, { default: de(() => [p(un, { opacity: ".06", scrim: "primary", contained: "", "model-value": "", persistent: "" })]), _: 1 })]), _: 1 }), p(ln, { cols: "6" }, { default: de(() => [p(on, { "append-icon": "mdi-open-in-new", class: "py-4", color: "surface-variant", href: "https://vuetifyjs.com/introduction/why-vuetify/#feature-guides", "prepend-icon": "mdi-star-circle-outline", rel: "noopener noreferrer", rounded: "lg", subtitle: "Explore available framework Features.", target: "_blank", title: "Features", variant: "text" }, { default: de(() => [p(un, { opacity: ".06", scrim: "primary", contained: "", "model-value": "", persistent: "" })]), _: 1 })]), _: 1 }), p(ln, { cols: "6" }, { default: de(() => [p(on, { "append-icon": "mdi-open-in-new", class: "py-4", color: "surface-variant", href: "https://vuetifyjs.com/components/all", "prepend-icon": "mdi-widgets-outline", rel: "noopener noreferrer", rounded: "lg", subtitle: "Discover components in the API Explorer.", target: "_blank", title: "Components", variant: "text" }, { default: de(() => [p(un, { opacity: ".06", scrim: "primary", contained: "", "model-value": "", persistent: "" })]), _: 1 })]), _: 1 }), p(ln, { cols: "6" }, { default: de(() => [p(on, { "append-icon": "mdi-open-in-new", class: "py-4", color: "surface-variant", href: "https://discord.vuetifyjs.com", "prepend-icon": "mdi-account-group-outline", rel: "noopener noreferrer", rounded: "lg", subtitle: "Connect with Vuetify developers.", target: "_blank", title: "Community", variant: "text" }, { default: de(() => [p(un, { opacity: ".06", scrim: "primary", contained: "", "model-value": "", persistent: "" })]), _: 1 })]), _: 1 })]), _: 1 })]), _: 1 })]), _: 1 })) } }, Uh = Z({ ...Te(), ...Zm({ fullHeight: !0 }), ...jt() }, "VApp"), Kh = Ce()({ name: "VApp", props: Uh(), setup(e, t) { let { slots: n } = t; const r = Wt(e), { layoutClasses: s, getLayoutItem: o, items: i, layoutRef: l } = tg(e), { rtlClasses: a } = Rn(); return Ne(() => { var u; return p("div", { ref: l, class: ["v-application", r.themeClasses.value, s.value, a.value, e.class], style: [e.style] }, [p("div", { class: "v-application__wrap" }, [(u = n.default) == null ? void 0 : u.call(n)])]) }), { getLayoutItem: o, items: i, theme: r } } }); function Yh() { const e = me(!1); return In(() => { window.requestAnimationFrame(() => { e.value = !0 }) }), { ssrBootStyles: E(() => e.value ? void 0 : { transition: "none !important" }), isBooted: Pn(e) } } const Gh = Z({ scrollable: Boolean, ...Te(), ...it({ tag: "main" }) }, "VMain"), qh = Ce()({ name: "VMain", props: Gh(), setup(e, t) { let { slots: n } = t; const { mainStyles: r } = Jm(), { ssrBootStyles: s } = Yh(); return Ne(() => p(e.tag, { class: ["v-main", { "v-main--scrollable": e.scrollable }, e.class], style: [r.value, s.value, e.style] }, { default: () => { var o, i; return [e.scrollable ? p("div", { class: "v-main__scroller" }, [(o = n.default) == null ? void 0 : o.call(n)]) : (i = n.default) == null ? void 0 : i.call(n)] } })), {} } }), Zh = { __name: "App", setup(e) { return (t, n) => { const r = zh, s = hg; return ur(), eo(Kh, null, { default: de(() => [p(qh, null, { default: de(() => [p(r)]), _: 1 }), p(s)]), _: 1 }) } } }, xu = td(Zh); sg(xu); xu.mount("#app");
